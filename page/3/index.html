<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="学习经验 &amp; 理论知识">
<meta property="og:type" content="website">
<meta property="og:title" content="HMK's blog">
<meta property="og:url" content="http://HawkAaron.github.io/page/3/index.html">
<meta property="og:site_name" content="HMK's blog">
<meta property="og:description" content="学习经验 &amp; 理论知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HMK's blog">
<meta name="twitter:description" content="学习经验 &amp; 理论知识">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://HawkAaron.github.io/page/3/"/>

  <title> HMK's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HMK's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Welcome!</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/mysql 远程数据库导入到本地数据库/" itemprop="url">
                  mysql 远程数据库导入到本地数据库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>mysqldump -h ‘114.212.111.123’ -uROSE -pxxxooo –opt –compress ITSM –skip-lock-tables | mysql -h localhost<br> -uroot -proot ITSMC<br>解释：<br>114.212.111.123 远程服务器名称<br>ROSE 远程数据库登录名<br>xxxooo 远程数据库登录密码<br>ITSM远程数据库名（即：复制的源）<br>localhost 本地数据库名称（一般情况下都是这个）<br>root 本地数据库登录名（一般情况下都是这个）<br>root 本地数据库登录密码（一般情况下都是这个）<br>ITSMC 本地（即：复制的目的）<br>sql解释：<br>mysqldump 是mysql的一个专门用于拷贝操作的命令<br>–opt 操作的意思<br>–compress 压缩要传输的数据<br>–skip-lock 忽略锁住的表（加上这句能防止当表有外键时的报错）<br>-tables 某数据库所有表<br>-h 服务器名称<br>-u 用户名（<em>后面无空格，直接加用户名）<br>-p 密码（</em>后面无空格，直接加密码）<br>注意：<br>-u、-p的后面没有空格，直接加用户名和密码！！！ </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/Java的内存回收机制/" itemprop="url">
                  Java的内存回收机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，这两方面工作都是由JVM自动完成的，降低了Java程序员的学习难度，避免了像C/C++直接操作内存的危险。但是，也正因为内存管理完全由JVM负责，所以也使Java很多程序员不再关心内存分配，导致很多程序低效，耗内存。因此就有了Java程序员到最后应该去了解JVM，才能写出更高效，充分利用有限的内存的程序。<br>1.Java在内存中的状态<br>首先我们先写一个代码为例子：<br>Person.java<br>12345678910111213141516171819<code>package``test;</code> <code>``import``java.io.Serializable;</code> <code>``public``class``Person
``implements``Serializable
 {</code> <code>``static``final``long``
serialVersionUID = 1L;</code> <code>``String
 name; ``//
 姓名</code> <code>``Person
 friend;    ``//朋友</code> <code>``public``Person()
 {}</code> <code>``public``Person(String
 name) {``         ``super``();``         ``this``.name
 = name;``     ``}`` ``}</code>Test.java<br>1234567891011121314<code>package``test;</code> <code>``public``class``Test{</code> <code>``public``static``void``
main(String[] args) {``         ``Person
 p1 = ``new``Person(``&quot;Kevin&quot;``);``         ``Person
 p2 = ``new``Person(``&quot;Rain&quot;``);``         ``Person
 p3 = ``new``Person(``&quot;Sunny&quot;``);</code> <code>``p1.friend
 = p2;``         ``p3
 = p2;``         ``p2
 = ``null``;``     ``}`` ``}</code>把上面Test.java中main方面里面的对象引用画成一个从main方法开始的对象引用图的话就是这样的（顶点是对象和引用，有向边是引用关系）：<br><a href="http://jbcdn2.b0.upaiyun.com/2013/03/download.png" title="Java的内存回收机制" target="_blank" rel="external"><img src="http://jbcdn2.b0.upaiyun.com/2013/03/download.png" alt="Java的内存回收机制" title="Java的内存回收机制"></a><br>当程序运行起来之后，把它在内存中的状态看成是有向图后，可以分为三种：<br>1）可达状态：在一个对象创建后，有一个以上的引用变量引用它。在有向图中可以从起始顶点导航到该对象，那它就处于可达状态。<br>2）可恢复状态：如果程序中某个对象不再有任何的引用变量引用它，它将先进入可恢复状态，此时从有向图的起始顶点不能再导航到该对象。在这个状态下，系统的垃圾回收机制准备回收该对象的所占用的内存，在回收之前，系统会调用finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态。<br>3）不可达状态：当对象的所有关联都被切断，且系统调用finalize()方法进行资源清理后依旧没有使该对象变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源。<br>上述三种状态的转换图如下：<br><a href="http://jbcdn2.b0.upaiyun.com/2013/03/download-1.png" title="Java的内存回收机制" target="_blank" rel="external"><img src="http://jbcdn2.b0.upaiyun.com/2013/03/download-1.png" alt="Java的内存回收机制" title="Java的内存回收机制"></a><br>2.Java对对象的4种引用<br>1）强引用 ：创建一个对象并把这个对象直接赋给一个变量，eg ：Person person = new Person(“sunny”); 不管系统资源有么的紧张，强引用的对象都绝对不会被回收，即使他以后不会再用到。<br>2）软引用 ：通过SoftReference类实现，eg : SoftReference<person> p = new SoftReference<person>(new Person(“Rain”));,内存非常紧张的时候会被回收，其他时候不会被回收，所以在使用之前要判断是否为null从而判断他是否已经被回收了。<br>3）弱引用 ：通过WeakReference类实现，eg : WeakReference<person> p = new WeakReference<person>(new Person(“Rain”));不管内存是否足够，系统垃圾回收时必定会回收。<br>4）虚引用 ：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference类和引用队列ReferenceQueue类联合使用实现，eg ：<br>123456789101112131415161718192021222324252627<code>package``test;</code> <code>``import``java.lang.ref.PhantomReference;`` ``import``java.lang.ref.ReferenceQueue;</code> <code>``public``class``Test{</code> <code>``public``static``void``
main(String[] args) {``         ``//创建一个对象``         ``Person
 person = ``new``Person(``&quot;Sunny&quot;``);   ``         ``//创建一个引用队列   ``         ``ReferenceQueue&lt;Person&gt;
 rq = ``new``ReferenceQueue&lt;Person&gt;();``         ``//创建一个虚引用，让此虚引用引用到person对象``         ``PhantomReference&lt;Person&gt;
 pr = ``new``PhantomReference&lt;Person&gt;(person,
 rq);``         ``//切断person引用变量和对象的引用``         ``person
 = ``null``;``         ``//试图取出虚引用所引用的对象``         ``//发现程序并不能通过虚引用访问被引用对象，所以此处输出为null``         ``System.out.println(pr.get());``         ``//强制垃圾回收``         ``System.gc();//提示jvm进行垃圾回收，进不进行回收旧是jvm的意愿了。``         ``System.runFinalization();//强制执行所有未引用对象的finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态。不可达状态将会被系统回收。``         ``//因为一旦虚引用中的对象被回收后，该虚引用就会进入引用队列中``         ``//所以用队列中最先进入队列中引用与pr进行比较，输出true``         ``System.out.println(rq.poll()
 == pr);``     ``}`` ``}</code>运行结果：<br><a href="http://jbcdn2.b0.upaiyun.com/2013/03/download-2.png" title="Java的内存回收机制" target="_blank" rel="external"><img src="http://jbcdn2.b0.upaiyun.com/2013/03/download-2.png" alt="Java的内存回收机制" title="Java的内存回收机制"></a><br>3.Java垃圾回收机制<br>其实Java垃圾回收主要做的是两件事：1）内存回收 2）碎片整理<br>3.1垃圾回收算法<br>1）串行回收（只用一个CPU）和并行回收（多个CPU才有用）：串行回收是不管系统有多少个CPU，始终只用一个CPU来执行垃圾回收操作，而并行回收就是把整个回收工作拆分成多个部分，每个部分由一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但复杂度增加，另外也有一些副作用，如内存随便增加。<br>2）并发执行和应用程序停止 ：应用程序停止（Stop-the-world）顾名思义，其垃圾回收方式在执行垃圾回收的同时会导致应用程序的暂停。并发执行的垃圾回收虽然不会导致应用程序的暂停，但由于并发执行垃圾需要解决和应用程序的执行冲突（应用程序可能在垃圾回收的过程修改对象），因此并发执行垃圾回收的系统开销比Stop-the-world高，而且执行时需要更多的堆内存。<br>3）压缩和不压缩和复制 ：<br>①支持压缩的垃圾回收器（标记-压缩 = 标记清除+压缩）会把所有的可达对象搬迁到一起，然后将之前占用的内存全部回收，减少了内存碎片。<br>②不压缩的垃圾回收器（标记-清除）要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片<br>③复制式的垃圾回收器：将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。<br><a href="http://jbcdn2.b0.upaiyun.com/2013/03/download-3.png" title="Java的内存回收机制" target="_blank" rel="external"><img src="http://jbcdn2.b0.upaiyun.com/2013/03/download-3.png" alt="Java的内存回收机制" title="Java的内存回收机制"></a><br>3.2堆内存的分代回收<br>1）分代回收的依据：<br>①对象生存时间的长短：大部分对象在Young期间就被回收<br>②不同代采取不同的垃圾回收策略：新（生存时间短）老（生存时间长）对象之间很少存在引用<br>2) 堆内存的分代：<br>①Young代 ：<br>Ⅰ回收机制 ：因为对象数量少，所以采用复制回收。<br>Ⅱ组成区域 ：由1个Eden区和2个Survivor区构成，同一时间的两个Survivor区，一个用来保存对象，另一个是空的；每次进行Young代垃圾回收的时候，就把Eden，From中的可达对象复制到To区域中，一些生存时间长的就复制到了老年代，接着清除Eden，From空间，最后原来的To空间变为From空间，原来的From空间变为To空间。<br>Ⅲ对象来源 ：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中。<br>Ⅳ回收频率 ：因为Young代对象大部分很快进入不可达状态，因此回收频率高且回收速度快<br><a href="http://jbcdn2.b0.upaiyun.com/2013/03/download-4.png" title="Java的内存回收机制" target="_blank" rel="external"><img src="http://jbcdn2.b0.upaiyun.com/2013/03/download-4.png" alt="Java的内存回收机制" title="Java的内存回收机制"></a><br>          <a href="http://jbcdn2.b0.upaiyun.com/2013/03/download-5.png" title="Java的内存回收机制" target="_blank" rel="external"><img src="http://jbcdn2.b0.upaiyun.com/2013/03/download-5.png" alt="Java的内存回收机制" title="Java的内存回收机制"></a><br>②Old代 ：<br>Ⅰ回收机制 ：采用标记压缩算法回收。<br>Ⅱ对象来源 ：1.对象大直接进入老年代。<br>2.Young代中生存时间长的可达对象<br>Ⅲ回收频率 ：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成。<br>③Permanent代 ：<br>Ⅰ用      途 ：用来装载Class，方法等信息，默认为64M，不会被回收<br>Ⅱ对象来源 ：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGen space的错误，这就是Permanent代内存耗尽所导致的错误。<br>Ⅲ回收频率 ：不会被回收<br>3.3常见的垃圾回收器<br>1）串行回收器（只使用一个CPU）：Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停，<br>2）并行回收器：对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理； 对Old代的处理和串行回收器完全一样，依旧是单线程。<br>3）并行压缩回收器：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：<br>① 将Old代划分成几个固定区域；<br>② mark阶段（多线程并行），标记可达对象；<br>③ summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域<br>④ compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间。<br>4）并发标识—清理回收（CMS）：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：<br>① 初始标识（程序暂停）：标记被直接引用的对象(一级对象)；<br>② 并发标识（程序运行）：通过一级对象寻找其他可达对象；<br>③ 再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）<br>④ 并发清理（程序运行）<br>4.内存管理小技巧<br>1）尽量使用直接量，eg：String javaStr = “小学徒的成长历程”;<br>2）使用StringBuilder和StringBuffer进行字符串连接等操作;<br>3）尽早释放无用对象;<br>4）尽量少使用静态变量;<br>5）缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache;<br>6）尽量不使用finalize()方法;<br>7）在必要的时候可以考虑使用软引用SoftReference。</person></person></person></person></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/Oracle11g安装及使用详解/" itemprop="url">
                  Oracle11g安装及使用详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、首先我们在官网下载Oracle11g，链接如下：<br><a href="http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html</a><br>注意系统位数和文件个数<br><img src="http://img.blog.csdn.net/20150410221936614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>两个文件都要下载，过程可能比价漫长，可以敲会代码或者做几篇阅读理解缓解一下情绪（为接下来操蛋的安装过程做好充分的心理准备）</p>
<p>二、安装可以参考已下链接<br><a href="http://jingyan.baidu.com/article/e5c39bf58eff9239d760338b.html" target="_blank" rel="external">http://jingyan.baidu.com/article/e5c39bf58eff9239d760338b.html</a><br>这里要注意一点：可以无视所有的错误提示！（在第5步进行先决条件检查时由于系统原因可能会报错，此时可以按照安装教程忽略相关选项！）<br>另外要注意的是安装目录尽量在跟目录下，比如安装在D:\Oracle\下，而且目录不能包含中文及空格等非数字字母的字符（大部分国外的大型程序都这样，我们只能默默地接受了）</p>
<p>三、环境变量检查<br>1、使用前请配置环境变量（系统会自动配置，最好检查一下）：<br>方法一：命令行 echo %PATH% 命令<br><img src="http://img.blog.csdn.net/20150410222254232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>可以看见图中的环境变量的第一条目录即是刚才安装完的Oracle的bin目录（一般软件的bin目录下有我们用到的命令行工具，Oracle的bin命令里面有sqlplus）<br>方法二：右击‘计算机’，选择‘属性’，‘高级系统配置’，<br><img src="http://img.blog.csdn.net/20150410222343106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150410222411545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150410222556299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><img src="http://img.blog.csdn.net/20150410222541124?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150410222609937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>变量值的最前面即刚才安装的Oracle的bin目录<br>（若path中没有Oracle的bin目录则把刚才安装oracle的目录里面的bin找出来加进去就行了，正常情况下是自动加的，如果没有就是安装有问题了）</p>
<p>四、登陆oracle：<br>登陆的方法有以下几种：<br>1、sqlplus登陆oracle：</p>
<pre><code>1.C: &gt; sqlplus &quot;/as sysdba&quot;   --以操作系统权限认证的oracle sys管理员登陆

2.C: &gt; sqlplus /nolog             --不在cmd或者terminal当中暴露密码的登陆方式
SQL&gt; conn /as sysdba
&amp;
SQL&gt; conn sys/password as sysdba

3.C: &gt; sqlplus scott/tiger      --非管理员用户登陆

4.C: &gt; sqlplus scott/tiger@orcl    --非管理员用户使用tns别名登陆

5.C: &gt; sqlplus sys/password@orcl as sysdba --管理员用户使用tns别名登陆
6.C: &gt; sqlplus                       --不显露密码的登陆方式
Enter user-name：sys
Enter password：password as sysdba     --以sys用户登陆的话 必须要加上 as sysdba 子句

![](http://img.blog.csdn.net/20150410222729400?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
这是我输入sqlplus后的效果，系统莫名其妙的提示输入用户名，用过MySQL的可能对这点感到很迷惑，一般安装完后都是root账户，但是oracle是个比MySQL强大很多倍的大型关系型数据库，用户名也有很多，如下：
    scott
    sys  
    system
    sysman 
    这些账户的密码设置会在安装过程中完成，其中system是我们设置的登陆口令，Scott也是可以在口令管理中管理的
</code></pre><p><a href="http://www.linuxidc.com/Linux/2011-03/33174.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2011-03/33174.htm</a></p>
<p>这个链接里面有比较详细的sqlplus的使用方法<br><a href="http://baike.baidu.com/link?url=GAgntfVfaPWk9Oam_8bWSv37PdWx6xQ-wZDP2TWCy8GWDnQlMI5T6JqWcflkw9jmfb3JXyTAjkfN-3Qp8nbryK#1" target="_blank" rel="external">http://baike.baidu.com/link?url=GAgntfVfaPWk9Oam_8bWSv37PdWx6xQ-wZDP2TWCy8GWDnQlMI5T6JqWcflkw9jmfb3JXyTAjkfN-3Qp8nbryK#1</a><br>以上是百度百科的介绍，可以参考<br><a href="http://jingyan.baidu.com/article/6525d4b155767dac7d2e94e8.html" target="_blank" rel="external">http://jingyan.baidu.com/article/6525d4b155767dac7d2e94e8.html</a><br>这个是Linux下的操作方法</p>
<p>2、使用Oracle控制台<br>打开chrome浏览器（或其它，不推荐使用IE），在地址栏中输入<a href="https://localhost:1158/em" target="_blank" rel="external">https://localhost:1158/em</a><br>可能会有不安全之类的提示，无视即可，输入用户名密码后就可以管理了<br>具体的使用方法可以参考已下链接<br><a href="http://jingyan.baidu.com/article/3c343ff72c71c10d3679636a.html" target="_blank" rel="external">http://jingyan.baidu.com/article/3c343ff72c71c10d3679636a.html</a><br>不过控制台的连接速度可能很慢，如果不能忍受的话就用命令行吧</p>
<p>3、第三方GUI管理工具<br>Toad：<br><a href="https://www.toadworld.com/?Redirected=true" target="_blank" rel="external">https://www.toadworld.com/?Redirected=true</a></p>
<p>PLSQL Developer：<br><a href="http://jingyan.baidu.com/article/c85b7a6403acd1003bac950f.html" target="_blank" rel="external">http://jingyan.baidu.com/article/c85b7a6403acd1003bac950f.html</a></p>
<p>五、管理Oracle<br>Oracle是地球上目前最强大的关系型数据库，用过MySQL的人可能刚开始对Oracle无从下手，想想当初你玩MySQL的时候不也是配置环境变量，百度登陆方法等等，所以我们要有耐心。最后一句话：打好基础。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/MySQL忘记密码/" itemprop="url">
                  MySQL忘记密码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>如果是root密码：

方法一：
MySQL提供跳过访问控制的命令行参数，通过在命令行以此命令启动MySQL服务器： 
safe_mysqld --skip-grant-tables&amp; 
即可跳过MySQL的访问控制，任何人都可以在控制台以管理员的身份进入MySQL数据库。 
需要注意的是在修改完密码以后要把MySQL服务器停掉重新启动才会生效

方法二：
可以进行如下的步骤重新设置MySQL的root密码： 
1．首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。 
因为在重新设置MySQL的root密码的期间，MySQL数据库完全出于没有密码保护的 
状态下，其他的用户也可以任意地登录和修改MySQL的信息。可以采用将MySQL对 
外的端口封闭，并且停止Apache以及所有的用户进程的方法实现服务器的准安全 
状态。最安全的状态是到服务器的Console上面操作，并且拔掉网线。 
2．修改MySQL的登录设置： 
# vi /etc/my.cnf 
在[mysqld]的段中加上一句：skip-grant-tables 
例如： 
[mysqld] 
datadir=/var/lib/mysql 
socket=/var/lib/mysql/mysql.sock 
skip-name-resolve 
skip-grant-tables 
保存并且退出vi。 
3．重新启动mysqld 
# /etc/init.d/mysqld restart 
Stopping MySQL: [ OK ] 
Starting MySQL: [ OK ] 
4．登录并修改MySQL的root密码 
# /usr/bin/mysql 
Welcome to the MySQL monitor. Commands end with ; or \g. 
Your MySQL connection id is 3 to server version: 3.23.56 
Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the buffer. 
mysql&gt; USE mysql ; 
Reading table information for completion of table and column names 
You can turn off this feature to get a quicker startup with -A 
Database changed 
mysql&gt; UPDATE user SET Password = password ( ‘new-password’ ) WHERE User = ‘root’ ; 
Query OK, 0 rows affected (0.00 sec) 
Rows matched: 2 Changed: 0 Warnings: 0 
mysql&gt; flush privileges ; 
Query OK, 0 rows affected (0.01 sec) 
mysql&gt; quit 
Bye 
5．将MySQL的登录设置修改回来 
# vi /etc/my.cnf 
将刚才在[mysqld]的段中加上的skip-grant-tables删除 
保存并且退出vi。 
6．重新启动mysqld 
# /etc/init.d/mysqld restart 
Stopping MySQL: [ OK ] 
Starting MySQL: [ OK ] 
windows 
1.以系统管理员身份登陆系统。 
  2.打开cmd—–net start 查看mysql是否启动。启动的话就停止net stop mysql. 
  3.我的mysql安装在d:\usr\local\mysql4\bin下。 
  4.跳过权限检查启动mysql. 
  d:\usr\local\mysql4\bin\mysqld-nt –skip-grant-tables 
  5.重新打开cmd。进到d:\usr\local\mysql4\bin下： 
  d:\usr\local\mysql4\bin\mysqladmin -uroot flush-privileges password “newpassword” 
  d:\usr\local\mysql4\bin\mysqladmin -u root -p shutdown 这句提示你重新输密码。 
  6.在cmd里net start mysql 
  7.搞定了。 
2，MySQL4.1以上版本一种密码错误问题的解决方法 
1 # SET PASSWORD FOR ’some_user’@’some_host’ = OLD_PASSWORD(‘newpwd’);   
2 # FLUSH PRIVILEGES;  
3，Mysql数据库修复 
myisamchk -r -q d:\mysql\data\latin1\* 
r代表修复 
q代表快速 
d:\mysql\data\latin1\*数据库里面 *代表里面的所有的文件  

方法三：
如果你忘记了你的MYSQL的root口令的话，你可以通过下面的过程恢复。
  1. 向mysqld server 发送kill命令关掉mysqld server(不是 kill -9),存放进程ID的文件通常在MYSQL的数据库所在的目录中。
      kill `cat /mysql-data-directory/hostname.pid`
     你必须是UNIX的root用户或者是你所运行的SERVER上的同等用户，才能执行这个操作。
  2. 使用`--skip-grant-tables&apos; 参数来启动 mysqld。
  3. 使用`mysql -h hostname mysql&apos;命令登录到mysqld server ，用grant命令改变口令。你也可以这样做：`mysqladmin -h hostname -u user password &apos;new password&apos;&apos;。
（其实也可以用use mysql; update user set password =password(&apos;yourpass&apos;) where user=&apos;root&apos; 来做到。）
  4. 载入权限表： `mysqladmin -h hostname flush-privileges&apos; ，或者使用 SQL 命令`FLUSH PRIVILEGES&apos;。（当然，在这里，你也可以重启mysqld。）

方法四：(一定要先备份)
1，重新在另一台电脑上安装相同版本的MySQL
2，删除忘记密码的电脑中MySQL安装目录中\data\mysql的全部内容（要先停止MySQL服务）
3，Copy新装的电脑上MySQL安装目录中\data\mysql的全部内容 to 刚刚删除的目录中4，启动MySQL服务

综述：cmd到MySQL安装目录，关闭mysql服务 **net stop mysql **输入mysqld-nt --skip-grant-tables 此时cmd处于监听状态(这个留着不要关了)，新开一个cmd，切换到MySQL安装目录，输入mysql  进入MySQL命令行后修改root账户密码(use mysql;   update user set password=password(&apos;root&apos;) where user=&apos;root&apos;;  flush privileges;)
此方法只要到MySQL安装目录即可，注意安装的MySQL一定要有mysqld-nt，完全安装就行了，毕竟才100多M
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/MySQL ERROR2013完美解决方案/" itemprop="url">
                  MySQL ERROR2013完美解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这个错误一般是安装了多个MySQL服务器导致的，解决方案如下：<br>1、进入MySQL安装目录：D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;<br>2、输入mysqld-nt -remove<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;mysqld-nt -remove<br>The service doesn’t exist!</p>
<p>3、输入mysqld-nt -install<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;mysqld-nt -install<br>Service successfully installed.<br>4、输入net start mysql<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;net start mysql<br>MySQL 服务正在启动 ……………….<br>MySQL 服务无法启动。<br>5、输入netstat -ano|findstr 3306<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;netstat -ano|findstr 3306<br>  TCP    0.0.0.0:3306           0.0.0.0:0              LISTENING       5804<br>6、输入taskkill -f -pid 5804（此处的5804即上面的进程ID）<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;taskkill -f -pid 5804<br>成功: 已终止 PID 为 5804 的进程。<br>7、输入net start mysql<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;net start mysql<br>MySQL 服务正在启动 .<br>MySQL 服务已经启动成功。<br>8、输入mysql -uroot -p进入MySQL</p>
<p>如果设置了环境变量，可在任意目录下执行以上命令</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/C语言连接MySQL（codeblocks）/" itemprop="url">
                  C语言连接MySQL（codeblocks）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></div><div class="line"><span class="comment">/*数据库连接用宏*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"localhost"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME <span class="meta-string">"root"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"root"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DATABASE <span class="meta-string">"mysql"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *query;</div><div class="line">    query=<span class="string">"select host,user from user"</span>;</div><div class="line">    query_sql(query);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sql</span><span class="params">(<span class="keyword">char</span>* sql)</span></span></div><div class="line">&#123;</div><div class="line">    MYSQL my_connection; <span class="comment">/*这是一个数据库连接*/</span></div><div class="line">    <span class="keyword">int</span> res; <span class="comment">/*执行sql語句后的返回标志*/</span></div><div class="line">    MYSQL_RES *res_ptr; <span class="comment">/*指向查询结果的指针*/</span></div><div class="line">    MYSQL_FIELD *field; <span class="comment">/*字段结构指针*/</span></div><div class="line">    MYSQL_ROW result_row; <span class="comment">/*按行返回的查询信息*/</span></div><div class="line">    <span class="keyword">int</span> row, column; <span class="comment">/*查询返回的行数和列数*/</span></div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="comment">/*初始化mysql连接my_connection*/</span></div><div class="line">    mysql_init(&amp;my_connection);</div><div class="line">    <span class="comment">/*建立mysql连接*/</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != mysql_real_connect(&amp;my_connection, HOST, USERNAME, PASSWORD,</div><div class="line">                                   DATABASE, <span class="number">0</span>, <span class="literal">NULL</span>, CLIENT_FOUND_ROWS))  <span class="comment">/*连接成功*/</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"数据库查询query_sql连接成功！\n"</span>);</div><div class="line">        <span class="comment">/*设置查询编码为gbk，以支持中文*/</span></div><div class="line">        mysql_query(&amp;my_connection, <span class="string">"set names gbk"</span>);</div><div class="line">        res = mysql_query(&amp;my_connection, sql);</div><div class="line">        <span class="keyword">if</span> (res)   <span class="comment">/*执行失败*/</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Error： mysql_query !\n"</span>);</div><div class="line">            <span class="comment">/*关闭连接*/</span></div><div class="line">            mysql_close(&amp;my_connection);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>     <span class="comment">/*现在就代表执行成功了*/</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">/*将查询的結果给res_ptr*/</span></div><div class="line">            res_ptr = mysql_store_result(&amp;my_connection);</div><div class="line">            <span class="comment">/*如果结果不为空，就把结果print*/</span></div><div class="line">            <span class="keyword">if</span> (res_ptr)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">/*取得結果的行数和*/</span></div><div class="line">                column = mysql_num_fields(res_ptr);</div><div class="line">                row = mysql_num_rows(res_ptr);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"查询到 %d 行 \n"</span>, row);</div><div class="line">                <span class="comment">/*输出結果的字段名*/</span></div><div class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; field = mysql_fetch_field(res_ptr); i++)</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"%10s "</span>, field-&gt;name);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">                <span class="comment">/*按行输出結果*/</span></div><div class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++)</div><div class="line">                &#123;</div><div class="line">                    result_row = mysql_fetch_row(res_ptr);</div><div class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; column; j++)</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">"%10s "</span>, result_row[j]);</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/*不要忘了关闭连接*/</span></div><div class="line">            mysql_close(&amp;my_connection);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"数据库连接失败"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意事项：<br>1.在Linker settings-&gt;Link libraries中添加libmysql.lib的路径<br>2.在Search directories-&gt;的Compiler中添加mysql.h的文件夹路径（总之就是让编译器能找到libmysql.lib和mysql.h）<br>3.在#include <mysql.h>之前添加#include <winsock2.h>（网上很多资料没有这一步，但是我这边实际操作时发现不加这一句编译无法通过）<br>运行结果：<br><img src="http://img.blog.csdn.net/20150606170050484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></winsock2.h></mysql.h></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/CodeBlocks静态链接与动态链接设置/" itemprop="url">
                  CodeBlocks静态链接与动态链接设置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##静态库和动态库的区别</p>
<p>###<a href=""></a>1.静态库</p>
<p>之所以称之为”静态库”，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。<br>从本质上来说，一个静态库可以简单看成是一组目标文件(.o/.obj文件)的集合，静态库与汇编生成的目标文件(.o/.obj)一起链接为可执行文件。<br>静态库（后缀为.a/.lib）和.o文件格式相似。即很多目标文件经过压缩打包后形成的一个文件<br>静态库特点总结：</p>
<pre><code>1. 静态库对函数库的链接是放在编译时期完成的
2. 程序在运行时与函数库再无瓜葛，移植方便，因为代码已经嵌入到程序里面了，可以直接跟着程序走，不存在对外部文件的依赖
3. 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件，会增加原本程序的空间
</code></pre><p><strong>GCC编译、使用静态库</strong><br>静态库的后缀是.a(并没有强制规定)，它的产生分两步</p>
<pre><code>1. 由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表
2. ar命令将很多.o转换成.a，成为静态库，从这点也可以看出来，库是很多.o文件的集合
</code></pre><p>编译好静态库文件之后，我们就可以在其他程序中使用静态库文件中的函数了</p>
<pre><code>1. 只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明(include对应的头文件)
2. 然后在用gcc命令生成目标文件时指明静态库名
3. gcc将会从静态库中将公用函数连接到目标文件中
4. 注意，gcc会在静态库名前加上前缀lib，然后追加扩展名.a得到的静态库文件名来查找静态库文件,因此，我们在写需要连接的库时，只写名字就可以，如libhello.a的库，只写: -lhello
</code></pre><p>###<a href=""></a>2.动态库</p>
<p>动态库文件名命名规范和静态库文件名命名规范类似，也是在动态库名增加前缀lib，但其文件扩展名为.so（.dll）。例如：我们将创建的动态库名为myhello，则动态库文件名就是libmyhello.so。<br>使用库是重用代码的一种绝佳方式。 您不必在自己创建的每个程序中重新实现同一例程，而只需对这些例程写入一次，然后从需要该功能的应用程序引用它们即可。 通过将代码放入 DLL，您节省在引用它的每个应用程序的空间，而且，您可以更新 DLL，而无需重新编译所有应用程序。<br>动态链接库 (DLL) 是作为共享函数库的可执行文件。动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个 DLL 副本的内容。<br>动态链接与静态链接的不同之处在于它允许可执行模块（.dll 文件或 .exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。在静态链接中，链接器从静态链接库获取所有被引用的函数，并将库同代码一起放到可执行文件中。<br>使用动态链接代替静态链接有若干优点。DLL 节省内存，减少交换操作，节省磁盘空间，更易于升级，提供售后支持，提供扩展 MFC 库类的机制，支持多语言程序，并使国际版本的创建轻松完成。<br><strong>DLL 的类型</strong><br>当您在应用程序中加载 DLL 时，可以使用两种链接方法来调用导出的 DLL 函数。这两种链接方法是加载时动态链接和运行时动态链接。<br>动态库一般会有对应的导入库，方便程序静态载入动态链接库，否则你可能就需要自己LoadLibary调入DLL文件，然后再手工GetProcAddress获得对应函数了。有了导入库，你只需要链接导入库后按照头文件函数接口的声明调用函数就可以了。<br><strong>加载时动态链接</strong>（load-time dynamic linking）<br>在加载时动态链接中，应用程序像调用本地函数一样对导出的 DLL 函数进行显式调用。要使用加载时动态链接，请在编译和链接应用程序时提供头文件 (.h) 和导入库文件 (.lib)。当您这样做时，链接器将向系统提供加载 DLL 所需的信息，并在加载时解析导出的 DLL 函数的位置。<br><strong>运行时动态链接</strong>（run-time dynamic linking）<br>在运行时动态链接中，应用程序调用 LoadLibrary 函数或 LoadLibraryEx 函数以在运行时加载 DLL。成功加载 DLL 后，可以使用 GetProcAddress 函数获得要调用的导出的 DLL 函数的地址。在使用运行时动态链接时，无需使用导入库文件。</p>
<p>所谓静态、动态是指”链接”的过程存在区别:<br><img src="http://img.blog.csdn.net/20141002194726705" alt=""></p>
<p>###<a href=""></a>3. DLL地狱<br>DLL地狱（DLL Hell）指在Microsoft Windows系统中，因为动态链接库（DLL）的版本或兼容性的问题而造成程序无法正常运行。<br>Windows早期并没有很严谨的DLL版本管理机制，以致经常发生安装了某软件后，因为其覆盖了系统上原有的同一个DLL文件，而导致原有可运行的程序无法运行。但还原回原有的DLL文件之后，所新安装的软件就无法运行。若覆盖到系统所使用的重要DLL时亦可能让系统容易死机甚至无法正常启动。<br>在CodeBlocks+GCC环境下，静态链接与动态链接设置如下：</p>
<p>##<a href=""></a>静态链接</p>
<p>###<a href=""></a>1.建立静态链接库</p>
<p>示例：<br>建立静态链接库工程，工程文件包括static.h和static.cpp，具体如下，然后编译工程，会生成一个libStaticLibrary.a文件。<br>libStaticLibrary.a是用于链接的，与其他文件一起编译生成一个exe执行文件。<strong>static.h</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="copy" target="_blank" rel="external">copy</a><a href="https://code.csdn.net/snippets/478749" title="在CODE上查看代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a><a href="https://code.csdn.net/snippets/478749/fork" title="派生到我的代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a>1. #ifndef STATIC_H_INCLUDED  </p>
<ol>
<li>#define STATIC_H_INCLUDED  </li>
<li></li>
<li>#ifdef __cplusplus  </li>
<li>extern “C”  </li>
<li>{  </li>
<li>#endif  </li>
<li></li>
<li>int SampleAddInt(int i1, int i2);  </li>
<li>void SampleFunction1();  </li>
<li>int SampleFunction2();  </li>
<li></li>
<li>#ifdef __cplusplus  </li>
<li>}  </li>
<li>#endif  </li>
<li></li>
<li>#endif // STATIC_H_INCLUDED  </li>
</ol>
<p><strong>static.cpp</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="copy" target="_blank" rel="external">copy</a><a href="https://code.csdn.net/snippets/478749" title="在CODE上查看代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a><a href="https://code.csdn.net/snippets/478749/fork" title="派生到我的代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a>1. #include “static.h”  </p>
<ol>
<li></li>
<li>// A function adding two integers and returning the result  </li>
<li>int SampleAddInt(int i1, int i2)  </li>
<li>{  </li>
<li>return i1 + i2;  </li>
<li>}  </li>
<li></li>
<li>// A function doing nothing ;)  </li>
<li>void SampleFunction1()  </li>
<li>{  </li>
<li>// insert code here  </li>
<li>}  </li>
<li></li>
<li>// A function always returning zero  </li>
<li>int SampleFunction2()  </li>
<li>{  </li>
<li>// insert code here  </li>
<li></li>
<li>return 0;  </li>
<li>}  </li>
</ol>
<p>###<a href=""></a>2.建立主工程</p>
<p>建立Console application，将生成一个main.cpp示例文件，在最上方添加#include “static.h”语句，这样就可以调用静态链接库里的函数了。<br><strong>main.cpp</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="copy" target="_blank" rel="external">copy</a><a href="https://code.csdn.net/snippets/478749" title="在CODE上查看代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a><a href="https://code.csdn.net/snippets/478749/fork" title="派生到我的代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a>1. #include <iostream>  </iostream></p>
<ol>
<li>#include “static.h”  </li>
<li>using namespace std;  </li>
<li></li>
<li>int main()  </li>
<li>{  </li>
<li>int a=1,b=2;  </li>
<li>cout &lt;&lt; “a + b = “&lt;&lt;SampleAddInt(a,b)&lt;&lt; endl;  </li>
<li>return 0;  </li>
<li>}  </li>
</ol>
<p>然后选择菜单栏Project-&gt;Build Options，弹出Project Build Options，选择工程名称。在Linker settings选项卡下添加libStaticLibrary.a的路径，即<strong>添加需要的库</strong>。在Search<br> directories选项卡下的Compiler子选项卡下添加static.h所在的目录路径，即写入项目的头文件目录。最后，点击编译即可。</p>
<p>##<a href=""></a>动态链接</p>
<p>###<a href=""></a>1.建立动态链接库<br>示例：<br>建立动态链接库工程，工程文件包括dynamic.h和dynamic.cpp，具体如下，然后编译工程，会生成一个libDynamicLibrary.a文件和DynamicLibrary.dll文件。<br>libDynamicLibrary.a是用于链接的，DynamicLibrary.dll用于与将要链接的exe执行文件一起工作。<br><strong>dynamic.h</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="copy" target="_blank" rel="external">copy</a><a href="https://code.csdn.net/snippets/478749" title="在CODE上查看代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a><a href="https://code.csdn.net/snippets/478749/fork" title="派生到我的代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a>1. #ifndef <strong>DYNAMIC_H</strong>  </p>
<ol>
<li>#define <strong>DYNAMIC_H</strong>  </li>
<li></li>
<li>#include <windows.h>  </windows.h></li>
<li></li>
<li>/*  To use this exported function of dll, include this header </li>
<li><ul>
<li>in your project. </li>
</ul>
</li>
<li>*/  </li>
<li></li>
<li>#ifdef BUILD_DLL  </li>
<li>#define DLL_EXPORT __declspec(dllexport)  </li>
<li>#else  </li>
<li>#define DLL_EXPORT __declspec(dllimport)  </li>
<li>#endif  </li>
<li></li>
<li></li>
<li>#ifdef __cplusplus  </li>
<li>extern “C”  </li>
<li>{  </li>
<li>#endif  </li>
<li></li>
<li>void DLL_EXPORT SomeFunction(const LPCSTR sometext);  </li>
<li></li>
<li>#ifdef __cplusplus  </li>
<li>}  </li>
<li>#endif  </li>
<li></li>
<li>#endif // <strong>DYNAMIC</strong>  </li>
</ol>
<p><strong>dynamic.cpp</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="copy" target="_blank" rel="external">copy</a><a href="https://code.csdn.net/snippets/478749" title="在CODE上查看代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a><a href="https://code.csdn.net/snippets/478749/fork" title="派生到我的代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a>1. #include “dynamic.h”  </p>
<ol>
<li></li>
<li>// a sample exported function  </li>
<li>void DLL_EXPORT SomeFunction(const LPCSTR sometext)  </li>
<li>{  </li>
<li>MessageBoxA(0, sometext, “DLL Message”, MB_OK | MB_ICONINFORMATION);  </li>
<li>}  </li>
<li></li>
<li>extern “C” DLL_EXPORT BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)  </li>
<li>{  </li>
<li>switch (fdwReason)  </li>
<li>{  </li>
<li>case DLL_PROCESS_ATTACH:  </li>
<li>// attach to process  </li>
<li>// return FALSE to fail DLL load  </li>
<li>break;  </li>
<li></li>
<li>case DLL_PROCESS_DETACH:  </li>
<li>// detach from process  </li>
<li>break;  </li>
<li></li>
<li>case DLL_THREAD_ATTACH:  </li>
<li>// attach to thread  </li>
<li>break;  </li>
<li></li>
<li>case DLL_THREAD_DETACH:  </li>
<li>// detach from thread  </li>
<li>break;  </li>
<li>}  </li>
<li>return TRUE; // succesful  </li>
<li>}  </li>
</ol>
<p>###<a href=""></a>2.建立主工程<br>建立win32 GUI project，将生成一个main.cpp示例文件，在最上方添加include “dynamic.h”语句，这样就可以调用动态链接库里的函数了。<br><strong>main.cpp</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/freewaywalker/article/details/39737699#" title="copy" target="_blank" rel="external">copy</a><a href="https://code.csdn.net/snippets/478749" title="在CODE上查看代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a><a href="https://code.csdn.net/snippets/478749/fork" title="派生到我的代码片" target="_blank" rel="external"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a>1. #include <windows.h>  </windows.h></p>
<ol>
<li></li>
<li>#include “dynamic.h”  </li>
<li></li>
<li>/<em>  Declare Windows procedure  </em>/  </li>
<li>LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);  </li>
<li></li>
<li>/<em>  Make the class name into a global variable  </em>/  </li>
<li>char szClassName[ ] = “CodeBlocksWindowsApp”;  </li>
<li></li>
<li>int WINAPI WinMain (HINSTANCE hThisInstance,  </li>
<li>HINSTANCE hPrevInstance,  </li>
<li>LPSTR lpszArgument,  </li>
<li>int nCmdShow)  </li>
<li>{  </li>
<li>HWND hwnd;               /<em> This is the handle for our window </em>/  </li>
<li>MSG messages;            /<em> Here messages to the application are saved </em>/  </li>
<li>WNDCLASSEX wincl;        /<em> Data structure for the windowclass </em>/  </li>
<li></li>
<li>/<em> The Window structure </em>/  </li>
<li>wincl.hInstance = hThisInstance;  </li>
<li>wincl.lpszClassName = szClassName;  </li>
<li>wincl.lpfnWndProc = WindowProcedure;      /<em> This function is called by windows </em>/  </li>
<li>wincl.style = CS_DBLCLKS;                 /<em> Catch double-clicks </em>/  </li>
<li>wincl.cbSize = sizeof (WNDCLASSEX);  </li>
<li></li>
<li>/<em> Use default icon and mouse-pointer </em>/  </li>
<li>wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION);  </li>
<li>wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION);  </li>
<li>wincl.hCursor = LoadCursor (NULL, IDC_ARROW);  </li>
<li>wincl.lpszMenuName = NULL;                 /<em> No menu </em>/  </li>
<li>wincl.cbClsExtra = 0;                      /<em> No extra bytes after the window class </em>/  </li>
<li>wincl.cbWndExtra = 0;                      /<em> structure or the window instance </em>/  </li>
<li>/<em> Use Windows’s default colour as the background of the window </em>/  </li>
<li>wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND;  </li>
<li></li>
<li>/<em> Register the window class, and if it fails quit the program </em>/  </li>
<li>if (!RegisterClassEx (&amp;wincl))  </li>
<li>return 0;  </li>
<li></li>
<li>/<em> The class is registered, let’s create the program</em>/  </li>
<li>hwnd = CreateWindowEx (  </li>
<li>0,                   /<em> Extended possibilites for variation </em>/  </li>
<li>szClassName,         /<em> Classname </em>/  </li>
<li>“Code::Blocks Template Windows App”,       /<em> Title Text </em>/  </li>
<li>WS_OVERLAPPEDWINDOW, /<em> default window </em>/  </li>
<li>CW_USEDEFAULT,       /<em> Windows decides the position </em>/  </li>
<li>CW_USEDEFAULT,       /<em> where the window ends up on the screen </em>/  </li>
<li>544,                 /<em> The programs width </em>/  </li>
<li>375,                 /<em> and height in pixels </em>/  </li>
<li>HWND_DESKTOP,        /<em> The window is a child-window to desktop </em>/  </li>
<li>NULL,                /<em> No menu </em>/  </li>
<li>hThisInstance,       /<em> Program Instance handler </em>/  </li>
<li>NULL                 /<em> No Window Creation data </em>/  </li>
<li>);  </li>
<li></li>
<li>/<em> Make the window visible on the screen </em>/  </li>
<li>ShowWindow (hwnd, nCmdShow);  </li>
<li></li>
<li>SomeFunction(“Dynamic Tester”);  </li>
<li></li>
<li>/<em> Run the message loop. It will run until GetMessage() returns 0 </em>/  </li>
<li>while (GetMessage (&amp;messages, NULL, 0, 0))  </li>
<li>{  </li>
<li>/<em> Translate virtual-key messages into character messages </em>/  </li>
<li>TranslateMessage(&amp;messages);  </li>
<li>/<em> Send message to WindowProcedure </em>/  </li>
<li>DispatchMessage(&amp;messages);  </li>
<li>}  </li>
<li></li>
<li>/<em> The program return-value is 0 - The value that PostQuitMessage() gave </em>/  </li>
<li>return messages.wParam;  </li>
<li>}  </li>
<li></li>
<li></li>
<li>/<em>  This function is called by the Windows function DispatchMessage()  </em>/  </li>
<li></li>
<li>LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)  </li>
<li>{  </li>
<li>switch (message)                  /<em> handle the messages </em>/  </li>
<li>{  </li>
<li>case WM_DESTROY:  </li>
<li>PostQuitMessage (0);       /<em> send a WM_QUIT to the message queue </em>/  </li>
<li>break;  </li>
<li>default:                      /<em> for messages that we don’t deal with </em>/  </li>
<li>return DefWindowProc (hwnd, message, wParam, lParam);  </li>
<li>}  </li>
<li></li>
<li>return 0;  </li>
<li>}  </li>
</ol>
<p>然后选择菜单栏Project-&gt;Build Options，弹出Project Build Options，选择工程名称。在Linker settings选项卡下添加libDynamicLibrary.a的路径，即<strong>添加需要的库</strong>。在Search directories选项卡下的Compiler子选项卡下添加dynamic.h所在的目录路径，即<strong>写入项目的头文件目</strong>录；在Linker子选项卡下添加libDynamicLibrary.a所在的目录路径，即<strong>写入库文件目录</strong>。最后，点击编译即可。<br>需要注意的是，以后单独运行编译后的exe执行文件时，需要将dll文件（此处为DynamicLibrary.dll）放在同一目录下，不然运行时可能会崩溃。<br><img src="http://img.blog.csdn.net/20141002185651049?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnJlZVdheVdhbGtlcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>参考：<br>codeblocks 配置编译器 1配置编译器的path, include, lib <a href="http://www.verydemo.com/demo_c167_i5481.html" target="_blank" rel="external">http://www.verydemo.com/demo_c167_i5481.html</a><br>C/C++ 跨平台交叉编译、静态库/动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项 <a href="http://www.cnblogs.com/LittleHann/p/3980364.html" target="_blank" rel="external">http://www.cnblogs.com/LittleHann/p/3980364.html</a><br>什么是DLL? <a href="http://support2.microsoft.com/kb/815065/zh-cn" target="_blank" rel="external">http://support2.microsoft.com/kb/815065/zh-cn</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/CC++ 跨平台交叉编译、静态库动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项/" itemprop="url">
                  C/C++ 跨平台交叉编译、静态库/动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>0. 引言</strong><br>UNIX是一个注册商标，是要满足一大堆条件并且支付可观费用才能够被授权使用的一个操作系统。linux是unix的克隆版本，是由其创始人Linus和诸多世界知名的黑客手工打造的一个操作系统。为什么linux和unix之间有很多软件可以很轻松的移植？因为linux也满足POSIX规范，所以在运行机制上跟unix相近。同时，POSIX标准也是Linux、windows下能够进行交叉编译的基础<br><strong><em>0x1: POSIX(Portable Operating System Interface)</em></strong><br>可移植操作系统接口(Portable Operating System Interface POSIX)，是IEEE为要在各种UNIX操作系统上运行的软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。它基本上是(Portable<br> Operating System Interface可移植操作系统接口)的缩写，而X则表明其对Unix API的传承<br>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。微软的Windows NT声称部分实现了POSIX标准，因为有POSIX标准的存在，我们在unix、linux、windows上进行编程的时候，会发现有很多API都是通用的，虽然大多数情况下进行跨系统兼容编程是很困难的<br>当前的POSIX主要分为四个部分</p>
<pre><code>1. Base Definitions2. System Interfaces3. Shell and Utilities4. Rationale
</code></pre><p><strong><em>0x2: POSIX 1.1标准</em></strong><br>POSIX(Portable Operating System Interface for Computing Systems)是由IEEE 和ISO/IEC 开发的一簇标准。该标准是基于现有的UNIX实践和经验，描述了操作系统的调用服务接口，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行。</p>
<p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    1. 1003.0管理POSIX开放式系统环境(OSE)。IEEE在1995年通过了这项标准。ISO的版本是ISO/IEC 14252:1996</p>
<pre><code>2. 1003.1被广泛接受、用于源代码级别的可移植性标准。1003.1提供一个操作系统的C语言应用编程接口(API)。IEEE和ISO已经在1990年通过了这个标准，IEEE在1995年重新修订了该标准。3. 1003.1b
一个用于实时编程的标准(以前的P1003.4或POSIX.4)。这个标准在1993年被IEEE通过，被合并进ISO/IEC 9945-1

4. 1003.1c
一个用于线程(在一个程序中当前被执行的代码段)的标准。以前是P1993.4或POSIX.4的一部分，这个标准已经在1995年被IEEE通过，归入ISO/IEC 9945-1:1996

5. 1003.1g
一个关于协议独立接口的标准，该接口可以使一个应用程序通过网络与另一个应用程序通讯。1996年，IEEE通过了这个标准6. 1003.2一个应用于shell和工具软件的标准，它们分别是操作系统所必须提供的命令处理器和工具程序。1992年IEEE通过了这个标准。ISO也已经通过了这个标准(ISO/IEC 9945-2:1993)7. 1003.2d改进的1003.2标准8. 1003.5一个相当于1003.1的Ada语言的API。在1992年，IEEE通过了这个标准。并在1997年对其进行了修订。ISO也通过了该标准9. 1003.5b
一个相当于1003.1b(实时扩展)的Ada语言的API。IEEE和ISO都已经通过了这个标准。ISO的标准是ISO/IEC 14519:1999

10. 1003.5c
一个相当于1003.1q(协议独立接口)的Ada语言的API。在1998年，IEEE通过了这个标准。ISO也通过了这个标准。11. 1003.9一个相当于1003.1的FORTRAN语言的API。在1992年，IEEE通过了这个标准，并于1997年对其再次确认。ISO也已经通过了这个标准12. 1003.10一个应用于超级计算应用环境框架(Application Environment Profile，AEP)的标准。在1995年，IEEE通过了这个标准13. 1003.13一个关于应用环境框架的标准，主要针对使用POSIX接口的实时应用程序。在1998年，IEEE通过了这个标准 14. 1003.22一个针对POSIX的关于安全性框架的指南15. 1003.23一个针对用户组织的指南，主要是为了指导用户开发和使用支持操作需求的开放式系统环境(OSE)框架16. 2003针对指定和使用是否符合POSIX标准的测试方法，有关其定义、一般需求和指导方针的一个标准。在1997年，IEEE通过了这个标准17. 2003.1这个标准规定了针对1003.1的POSIX测试方法的提供商要提供的一些条件。在1992年，IEEE通过了这个标准18. 2003.2一个定义了被用来检查与IEEE 1003.2(shell和工具API)是否符合的测试方法的标准。在1996年，IEEE通过了这个标准
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><em>*</em>0x3: POSIX标准的意义</p>
<hr>
<p>POSIX的意义在于提供了”跨操作系统兼容性编译”的能力，遵循了POSIX标准的C/C++程序源代码，可以直接在Linux/BSD环境下用GCC编译，或者在windows下用Cygwin/MinGW编译(Cygwin、MinGW提供了跨操作系统的兼容编译)。这叫跨操作系统的编译，注意要和”跨平台交叉编译”区分开来<br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="external">http://zh.wikipedia.org/wiki/POSIX</a><br>    <a href="http://i.linuxtoy.org/docs/guide/ch48s05.html" target="_blank" rel="external">http://i.linuxtoy.org/docs/guide/ch48s05.html</a></p>
<p><strong>1. 交叉编译</strong><br><strong><em>0x1: 交叉编译简介</em></strong><br>从编译所在的平台和运行所在的平台这点来看，有两种编译概念<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    1. 本地编译<br>    我们常见的软件开发，都是属于”本地编译”。在当前的PC下，x86的CPU下，直接编译出来程序，可以运行的程序(或者库文件)，其可以直接在当前的环境，即x86的CPU下，当前电脑中，运行。<br>    此时的编译，可以叫做”本地编译”，即在当前目标平台下，编译出来的程序，也只是放到当前平台下，就可以运行的2. 交叉编译<br>    这是一个和本地编译相对应的概念。而所谓的”交叉编译”，就是在一种平台上编译，编译出来的程序，是放到别的平台上运行<br>    即编译的环境，和运行的环境，不一样，属于交叉的，此所谓cross交叉编译，这个概念，主要和嵌入式开发有关<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>一种最常见的例子就是：<br>    在进行嵌入式开发时，手上有个嵌入式开发板，CPU是arm的，然后在x86的平台下开发，比如Ubuntu的Linux，或者是Win7。然后就需要在x86的平台上，(用交叉编译器)去编译你写好的程序代码，编译生成的(可执行的)程序，是放<br>    到目标开发板，arm的CPU上运行的<br>    此所谓：在x86平台上编译，在ARM平台上运行<br>交叉编译，英文常写作cross compile，也有其他写法：crosscompile, cross compiling等<br><em>*</em>0x2: 为何要有交叉编译</p>
<hr>
<p>之所以要有交叉编译，主要原因是：<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    1. 嵌入式系统中的资源太少<br>    交叉编译出来的程序，所要运行的目标环境中，各种资源，都相对有限，所以很难进行直接的本地编译，最常见的情况是：<br>    因为编译，开发，都需要相对比较多的CPU，内存，硬盘等资源，而嵌入式开发上的那点资源，只够嵌入式(Linux)系统运行的，没太多剩余的资源，供你本地编译。所以需要在别的平台上进行跨平台编译，然后在其他的平台上运行<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><strong><em>0x3: 跨平台编译和跨操作系统编译的差别</em></strong><br>这里需要注意的是”平台”的概念，实际上包含两个概念</p>
<pre><code>1. 体系结构(Architecture): 同一个体系结构可以运行不同的操作系统2. 操作系统(Operating System): 同一个操作系统也可以在不同的体系结构上运行
</code></pre><p>举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称<br>像crosstool-NG这类交叉编译器和Cygwin这类跨操作系统平台编译器的区别在于</p>
<pre><code>1. crosstool-NG跨平台编译(跨体系结构、操作系统)2. Cygwin跨平台编译(提供*inux到windows系统的代码级编译兼容性)
</code></pre><p><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://www.crifan.com/files/doc/docbook/cross_compile/release/html/cross_compile.html" target="_blank" rel="external">http://www.crifan.com/files/doc/docbook/cross_compile/release/html/cross_compile.html</a><br>    <a href="http://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</a><br>    <a href="http://baike.baidu.com/view/650389.htm" target="_blank" rel="external">http://baike.baidu.com/view/650389.htm</a></p>
<p><strong>2. Cygwin简介</strong><br><strong><em>0x1: 简介</em></strong><br>Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft Windows上，运行类UNIX系统。Cygwin的主要目的是通过”重新编译”(注意：是重新编译)，将POSIX系统(例如Linux、BSD，以及其他Unix系统)上的软件移植到Windows上。Cygwin移植工作在Windows NT上比较好，在Windows 95和Windows 98上，相对差劲一些。目前Cygwin由Red Hat等负责维护<br>首要需要明白的是，Cygwin不是一个跨平台模拟器，它不能让我们把linux上编译出来的程序在windows上运行(像wine那样)，而是一个跨平台的编译器，也就是提供代码级的跨操作系统兼容性，我们在linux下写的符合POSIX标准的C程序可以在windows下面进行编译，Cygwin提供了一套在windows下可以使用的Linux的API<br>Cygwin包括了一套库，该库在Win32系统下实现了POSIX系统调用的API。还有一套GNU开发工具集(比如GCC、GDB)，这样可以进行简单的软件开发。还有一些UNIX系统下的常见程序。2001年，新增了X Window System<br><strong><em>0x2: Cygwin的特性</em></strong><br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    Cygwin is:1. a large collection of GNU and Open Source tools which provide functionality similar to a Linux distribution on Windows.2. a DLL (cygwin1.dll) which provides substantial POSIX API functionality.</p>
<pre><code>Cygwin is not:1. a way to run native Linux apps on Windows. You must rebuild your application from source if you want it to run on Windows.2. a way to magically make native Windows apps aware of UNIX® functionality like signals, ptys, etc. Again, you need to build your apps from source if you want to take advantage 
of Cygwin functionality.
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><strong><em>0x3: Cygwin原理</em></strong><br>cygnus当初首先把GCC，GDB，GAS等开发工具进行了改进，使他们能够生成并解释win32的目标文件。然后，他们要把这些工具移植到windows平台上去。一种方案是基于win32 api对这些工具的源代码进行大幅修改，这样做显然需要大量工作。因此，他们采取了一种不同的方法<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    1. 他们写了一个共享库(就是cygwin.dll)，把win32 api中没有的unix风格的调用(如fork、spawn、signals、select、sockets等)封装在里面2. 也就是说，他们基于win32 api写了一个unix系统库的模拟层(这个模拟层是一个关键，它的底层是win32 api，上层提供unix风格的调用，所以我们才可以在windows下编译unix风格的C程序)3. 这样，只要把这些工具的源代码和这个共享库连接到一起，就可以使用unix主机上的交叉编译器来生成可以在windows平台上运行的工具集4. 以这些移植到windows平台上的开发工具为基础，cygnus又逐步把其他的工具(几乎不需要对源代码进行修改，只需要修改他们的配置脚本)软件移植到windows上来。这样，在windows平台上运行bash和开发工具、用户工具，感觉好<br>    像在unix上工作<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><strong><em>0x4: 使用Cygwin编程</em></strong><br>code<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    #iuclude <stdio.h>main()<br>    {<br>        printf(“hello world!!\n”);<br>    }<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>编译<br>    gcc hello.c -o hello.exe<br>得到hello.exe，这个程序可以在windows上直接点击运行<br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://zh.wikipedia.org/wiki/Cygwin" target="_blank" rel="external">http://zh.wikipedia.org/wiki/Cygwin</a><br>    <a href="https://www.cygwin.com/" target="_blank" rel="external">https://www.cygwin.com/</a><br>    <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-cygwin/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-cygwin/</a></stdio.h></p>
<p><strong>3. 静态库编译及使用</strong><br><strong><em>0x1: 什么是库</em></strong><br>库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在是很有必要的<br>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种</p>
<pre><code>1. 静态库(.a、.lib)2. 动态库(.so、.dll)
</code></pre><p>所谓静态、动态是指”链接”的过程存在区别<br><img src="http://images.cnitblog.com/blog/532548/201409/191103358154415.png" alt=""><br><strong><em>0x2: 动态库和静态库的默认路径PATH搜索顺序</em></strong><br>库文件在连接(静态库和共享库)和运行(仅限于使用共享库的程序)时被使用，其搜索路径是在系统中进行设置的<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    1. 静态库的搜索路径顺序<br>        1) /lib<br>        2) /usr/lib<br>        3) /etc/ld.so.conf文件中添加库的搜索路径<br>        4) /etc/ld.so.conf.d下新建一个.conf文件，这种方法可以很灵活地将不同软件的库搜索路径区分开来2. 动态库的搜索路径顺序<br>        1) LD_LIBRARY_PATH<br>        2) /lib<br>        3) /usr/lib<br>        4) /etc/ld.so.cache(使用ldconfig生成的库路径缓存)<br>        5) /etc/ld.so.conf文件中添加库的搜索路径<br>        6) /etc/ld.so.conf.d下新建一个.conf文件，这种方法可以很灵活地将不同软件的库搜索路径区分开来<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>0x3: 静态库<br>之所以称之为”静态库”，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。<br>从本质上来说，一个静态库可以简单看成是一组目标文件(.o/.obj文件)的集合，静态库与汇编生成的目标文件(.o/.obj)一起链接为可执行文件<br>静态库和.o文件格式相似。即很多目标文件经过压缩打包后形成的一个文件<br>静态库特点总结：</p>
<pre><code>1. 静态库对函数库的链接是放在编译时期完成的2. 程序在运行时与函数库再无瓜葛，移植方便，因为代码已经嵌入到程序里面了，可以直接跟着程序走，不存在对外部文件的依赖3. 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件，会增加原本程序的空间
</code></pre><p>0x4: 静态库编程<br>我们接下来学习一下如何创建用于C++应用的静态库(一个.lib 文件)。 使用静态库是重用代码的一种绝佳方式。 你不必在要求功能的每个应用中重新实现同一例程，而只需将其写入静态库一次，然后从应用引用它们即可。<br> 从静态库链接的代码成为了应用的一部分，这样你就不必安装另一个文件来使用代码。<br><strong>1. VS编译、使用静态库</strong><br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    //创建静态库项目</p>
<pre><code>1. 在菜单栏上，依次选择&quot;文件&quot;、&quot;新建&quot;、&quot;项目&quot;
2. 在&quot;新建项目&quot;对话框的左窗格中，依次展开&quot;已安装&quot;、&quot;模板&quot;、&quot;Visual C++&quot;，然后选择&quot;Win32&quot;
3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;
4. 在&quot;名称&quot;框中为项目指定名称，例如 MathFuncsLib。 在&quot;解决方案名称&quot;框中为解决方案指定名称，例如 StaticLibrary。 选择&quot;确定&quot;按钮5. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮6. 在&quot;应用程序设置&quot;页的&quot;应用程序类型&quot;下，选择&quot;静态库&quot;
7. 在&quot;应用程序设置&quot;页的&quot;附加选项&quot;下，清除&quot;预编译头&quot;复选框8. 选择&quot;完成&quot;按钮创建项目
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>MathFuncsLib.h<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    // MathFuncsLib.h</p>
<pre><code>#ifndef MATHFUNCSLIB_H  #define MATHFUNCSLIB_H  

namespace MathFuncs
{
    class MyMathFuncs
    {
    public:
        // Returns a + b
        static double Add(double a, double b);

        // Returns a - b
        static double Subtract(double a, double b);

        // Returns a * b
        static double Multiply(double a, double b);

        // Returns a / b
        static double Divide(double a, double b);
    };
}  
  #endif  
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>MathFuncsLib.cpp<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    // MathFuncsLib.cpp// compile with: cl /c /EHsc MathFuncsLib.cpp// post-build command: lib MathFuncsLib.obj</p>
<pre><code>#include &quot;MathFuncsLib.h&quot;#include &lt;stdexcept&gt;

using namespace std;namespace MathFuncs
{
    double MyMathFuncs::Add(double a, double b)
    {
        return a + b;
    }

    double MyMathFuncs::Subtract(double a, double b)
    {
        return a - b;
    }

    double MyMathFuncs::Multiply(double a, double b)
    {
        return a * b;
    }

    double MyMathFuncs::Divide(double a, double b)
    {
        return a / b;
    }
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>编译静态库文件<br>    //编译此静态库</p>
<pre><code>1. 在菜单栏上依次选择&quot;生成&quot;、&quot;生成解决方案&quot;
2. 这将创建一个可供其他程序使用的静态库
</code></pre><p>vs是windows操作系统下的编译平台，通过vs编译得到的.lib静态库只能在windows的程序代码中使用，主要是编译器、汇编器和连接器的不同，因此二者库的二进制是不兼容的。文章之后会学习到如何将linux下编译的静态库通过跨平台编译链接到windows的程序代码中<br>要在其他程序中使用静态库中的功能，必须引用静态库才能使用其中的例程<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    //创建引用静态库的 C++ 控制台应用</p>
<pre><code>1. 在菜单栏上，依次选择&quot;文件&quot;、&quot;新建&quot;、&quot;项目&quot;。2. 在左窗格中的&quot;Visual C++&quot;下，选择&quot;Win32&quot;。3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;。4. 在&quot;名称&quot;框中为项目指定名称，例如 MyExecRefsLib。 在&quot;解决方案&quot;旁的下拉列表中选择&quot;添加到解决方案&quot;。 这会将新项目添加到包含此静5. 态库的解决方案。 选择&quot;确定&quot;按钮。6. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮。7. 在&quot;应用程序设置&quot;页的&quot;应用程序类型&quot;下，选择&quot;控制台应用程序&quot;。8. 在&quot;应用程序设置&quot;页的&quot;附加选项&quot;下，清除&quot;预编译头&quot;复选框。9. 选择&quot;完成&quot;按钮创建项目。
 //在应用中使用静态库的功能
1. 在创建一个控制台应用程序后，一个空的程序已经为你创建好了。 源文件的名称与你之前选择的名称相同。 在此示例中，源文件名为 MyExecRefsLib.cpp。2. 必须引用静态库才能使用其中的算术例程。 为此，请在&quot;解决方案资源管理器&quot;中打开 MyExecRefsLib 项目的快捷菜单，然后选择&quot;引用&quot;。 在 MyExecRefsLib&quot;属性页&quot;对话框中，展开&quot;通用属性&quot;节点，选择&quot;框架和引用&quot;，然后
选择&quot;添加新引用&quot;按钮。 有关&quot;引用&quot;对话框的更多信息，请参见&quot;&lt;Projectname&gt; 属性页&quot;对话框 -&gt;&quot;通用属性&quot;-&gt;&quot;框架和引用&quot;。3. &quot;添加引用&quot;对话框列出了可以引用的库。 &quot;项目&quot;选项卡列出了当前解决方案中的所有项目以及它们包含的所有库。 在&quot;项目&quot;选项卡上，选中&quot;MathFuncsLib&quot;复选框，然后选择&quot;确定&quot;按钮。4. 若要引用 MathFuncsLib.h 头文件，必须修改包含的目录路径。 在 MyExecRefsLib&quot;属性页&quot;对话框中，依次展开&quot;配置属性&quot;节点和&quot;C/C++&quot;节点，然后选择&quot;常规&quot;。 在&quot;附加包含目录&quot;旁，指定 MathFuncsLib 目录的路径或
浏览至该目录。5. 若要浏览至目录路径，请打开属性值下拉列表框，然后选择&quot;编辑&quot;。 在&quot;附加包含目录&quot;对话框中，在文本框中选择一个空行，然后选择行尾的省略号按钮 (…)。 在&quot;选择目录&quot;对话框中，选择 MathFuncsLib 目录，然后选择&quot;选择
文件夹&quot;按钮以保存所做选择并关闭对话框。 在&quot;附加包含目录&quot;对话框中，选择&quot;确定&quot;按钮，然后在&quot;属性页&quot;对话框中，选择&quot;确定&quot;按钮以保存对该项目进行的更改。
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><img src="" alt=""><br>MyExecRefsLib.cpp<strong> 
</strong><br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    // MyExecRefsLib.cpp// compile with: cl /EHsc MyExecRefsLib.cpp /link MathFuncsLib.lib</p>
<pre><code>#include &lt;iostream&gt;#include &quot;MathFuncsLib.h&quot;

using namespace std;int main()
{
    double a = 7.4;
    int b = 99;

    cout &lt;&lt; &quot;a + b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Add(a, b) &lt;&lt; endl;
    cout &lt;&lt; &quot;a - b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Subtract(a, b) &lt;&lt; endl;
    cout &lt;&lt; &quot;a * b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Multiply(a, b) &lt;&lt; endl;
    cout &lt;&lt; &quot;a / b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Divide(a, b) &lt;&lt; endl;

    return 0;
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><strong><strong><img src="" alt=""></strong></strong><br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://msdn.microsoft.com/zh-cn/library/ms235627.aspx#BKMK_CreateLibProject" target="_blank" rel="external">http://msdn.microsoft.com/zh-cn/library/ms235627.aspx#BKMK_CreateLibProject</a><br><strong>2. GCC编译、使用静态库</strong><br>静态库的后缀是.a(并没有强制规定)，它的产生分两步</p>
<pre><code>1. 由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表2. ar命令将很多.o转换成.a，成为静态库，从这点也可以看出来，库是很多.o文件的集合
</code></pre><p>在linux下，库文件一般放在/usr/lib和/lib下<br>静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称<br>动态库的名字一般为libxxxx.so.major.minor，xxxx是该lib的名称，major是主版本号，minor是副版本号(如果库的命名不遵循 libXXXXX.a的格式就找不到相应文件)<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    ldd命令可以查看一个可执行程序依赖的共享库<br>    ldd /bin/ping<br>        linux-gate.so.1 =&gt;  (0x006cd000)<br>        libidn.so.11 =&gt; /lib/libidn.so.11 (0x005d6000)<br>        libc.so.6 =&gt; /lib/libc.so.6 (0x00927000)<br>        /lib/ld-linux.so.2 (0x005ac000)<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>首先，我们先完成函数库(静态库的代码)的编码<br>hello.h: 函数库(静态库)的头文件<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    #ifndef HELLO_H#define HELLO_H</p>
<pre><code>void hello(const char* name);#endif
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>hello.c: 函数库的实现代码<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    #include <stdio.h></stdio.h></p>
<pre><code>void hello(const char* name)
{
    printf(&quot;Hello%s!\n&quot;, name);
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>现在，我们可以将当前的代码编译为静态库文件，需要注意的，静态库和可执行在本质上都是可执行代码，但是静态库没有main主程序，所以不能独立运行，需要被引入到别的程序中进行运行<br>    //将代码编译为对象文件.o<br>    gcc -c hello.c//将.o链接为静态库文件<br>    ar rcs libhello.a hello.o<br><img src="" alt=""><br>编译好静态库文件之后，我们就可以在其他程序中使用静态库文件中的函数了</p>
<pre><code>1. 只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明(include对应的头文件)2. 然后在用gcc命令生成目标文件时指明静态库名3. gcc将会从静态库中将公用函数连接到目标文件中4. 注意，gcc会在静态库名前加上前缀lib，然后追加扩展名.a得到的静态库文件名来查找静态库文件,因此，我们在写需要连接的库时，只写名字就可以，如libhello.a的库，只写: -lhello
</code></pre><p>main.c: 调用静态库的程序代码<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    #include “hello.h”</p>
<pre><code>int main()
{
    hello(&quot;LittleHann&quot;);
    return 0;
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>编译<br>    gcc -o hello main.c -L. -lhello<br>关于gcc的编译指令，请参阅另一篇文章<br>    <a href="http://www.cnblogs.com/LittleHann/p/3855905.html" target="_blank" rel="external">http://www.cnblogs.com/LittleHann/p/3855905.html</a><br><img src="" alt=""><br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://wenku.baidu.com/view/7d8602b265ce050877321301.html" target="_blank" rel="external">http://wenku.baidu.com/view/7d8602b265ce050877321301.html</a></p>
<p><strong>4. 动态库编译及使用</strong><br><strong><em>0x1: 动态库</em></strong><br>动态库文件名命名规范和静态库文件名命名规范类似，也是在动态库名增加前缀lib，但其文件扩展名为.so。例如：我们将创建的动态库名为myhello，则动态库文件名就是libmyhello.so。<br>接下来我们继续学习如何创建用于 C++ 应用程序的动态链接库 (DLL)。 使用库是重用代码的一种绝佳方式。 您不必在自己创建的每个程序中重新实现同一例程，而只需对这些例程写入一次，然后从需要该功能的应用程序引用它们即可。 通过将代码放入 DLL，您节省在引用它的每个应用程序的空间，而且，您可以更新 DLL，而无需重新编译所有应用程序<br><strong><em>0x2: 动态库编程</em></strong><br><strong>1. VS编译、使用静态库</strong><br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    //创建动态链接库 (DLL) 项目</p>
<pre><code>1. 在菜单栏上，依次选择&quot;文件&quot;、&quot;新建&quot;、&quot;项目&quot;。2. 在&quot;新建项目&quot;对话框的左窗格中，依次展开&quot;已安装&quot;、&quot;模板&quot;、&quot;Visual C++&quot;，然后选择&quot;Win32&quot;。3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;。4. 在&quot;名称&quot;框中为项目指定名称，例如，MathFuncsDll。 在&quot;解决方案名称&quot;框中为解决方案指定一个名称，例如 DynamicLibrary。 选择&quot;确定&quot;按钮。5. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮。6. 在&quot;应用程序设置&quot;页上的&quot;应用程序类型&quot;下，选择&quot;DLL&quot;。7. 选择&quot;完成&quot;按钮创建项目。
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>编写动态库DLL的头文件，MathFuncsDll.h<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    // MathFuncsDll.h</p>
<pre><code>#ifndef MATHFUNCSDll_H#define MATHFUNCSDll_H

/*当定义了 MATHFUNCSDLL_EXPORTS 符号时，MATHFUNCSDLL_API 符号将在此代码中的成员函数声明中设置 __declspec(dllexport) 修饰符，此修饰符使函数能作为 DLL 导出，以供其他应用程序调用
当 MATHFUNCSDLL_EXPORTS 未定义时，MATHFUNCSDLL_API 会在成员函数声明中定义 __declspec(dllimport) 修饰符。 此修饰符能够使编译器优化从 DLL 导入的用于其他应用程序的函数
默认情况下，生成 MathFuncsDll 项目时会定义 MATHFUNCSDLL_EXPORTS*/#ifdef MATHFUNCSDLL_EXPORTS
    #define MATHFUNCSDLL_API __declspec(dllexport) 
#else
    #define MATHFUNCSDLL_API __declspec(dllimport) 
#endif

namespace MathFuncs
{
    // This class is exported from the MathFuncsDll.dll
    class MyMathFuncs
    {
    public: 
        // Returns a + b
        static MATHFUNCSDLL_API double Add(double a, double b); 

        // Returns a - b
        static MATHFUNCSDLL_API double Subtract(double a, double b); 

        // Returns a * b
        static MATHFUNCSDLL_API double Multiply(double a, double b); 

        // Returns a / b
        // Throws const std::invalid_argument&amp; if b is 0
        static MATHFUNCSDLL_API double Divide(double a, double b); 
    };
}#endif
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>编写动态库DLL的函数实现的.cpp文件<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    // MathFuncsDll.cpp : Defines the exported functions for the DLL application.//#include “stdafx.h”#include “MathFuncsDll.h”#include <stdexcept></stdexcept></p>
<pre><code>using namespace std;namespace MathFuncs
{
    double MyMathFuncs::Add(double a, double b)
    {
        return a + b;
    }

    double MyMathFuncs::Subtract(double a, double b)
    {
        return a - b;
    }

    double MyMathFuncs::Multiply(double a, double b)
    {
        return a * b;
    }

    double MyMathFuncs::Divide(double a, double b)
    {
        if (b == 0)
        {
            throw invalid_argument(&quot;b cannot be zero!&quot;);
        }

        return a / b;
    }
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>编译后可以得到一个.dll文件<br><img src="" alt=""><br>编译得到一个dll文件后，我们就在其他的程序代码中去引入这个dll文件，并使用其中的函数功能了<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    //创建引用 DLL 的应用程序</p>
<pre><code>1. 为了创建一个项目引用你刚刚创建好的DLL，在菜单栏中选择 文件&gt;新建&gt;项目。2. 在左窗格中的&quot;Visual C++&quot;下，选择&quot;Win32&quot;。3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;。4. 在&quot;名称&quot;框中为项目指定名称，例如，MyExecRefsDll。 从&quot;解决方案&quot;旁边的下拉列表中选择&quot;添加到解决方案&quot;。 这会将新项目添加到包含 DLL 的同一个解决方案中。 选择&quot;确定&quot;按钮。5. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮。6. 在&quot;应用程序设置&quot;页的&quot;应用程序类型&quot;下，选择&quot;控制台应用程序&quot;。7. 在&quot;应用程序设置&quot;页的&quot;附加选项&quot;下，清除&quot;预编译头&quot;复选框。8. 选择&quot;完成&quot;按钮创建项目。//在应用程序中使用类库的功能
1. 在创建一个控制台应用程序后，一个空的程序已经为你创建好了。 源文件的名称与你之前选择的名称相同。 在本示例中，名为&quot;MyExecRefsDll.cpp&quot;。2. 若要使用您 DLL 中创建的算术例程，必须引用 DLL。 为此，请在 解决方案资源管理器 中选择 MyExecRefsDll 项目，然后在菜单栏上，选择 项目，引用。 在&quot;属性页&quot;对话框中，展开&quot;通用属性&quot;节点，选择&quot;框架和引用&quot;，然
后选择&quot;添加新引用&quot;按钮。 有关&quot;引用&quot;对话框的更多信息，请参见&quot;&lt;Projectname&gt; 属性页&quot;对话框 -&gt;&quot;通用属性&quot;-&gt;&quot;框架和引用&quot;。3. &quot;添加引用&quot;对话框列出了可以引用的库。 &quot;项目&quot;选项卡列出了当前解决方案中的所有项目，以及它们包含的所有库。 在&quot;项目&quot;选项卡上，选中&quot;MathFuncsDll&quot;旁边的复选框，然后选中&quot;确定&quot;按钮。4. 若要引用 DLL 的头文件，必须修改包含的目录路径。 为此，请在&quot;属性页&quot;对话框中展开&quot;配置属性&quot;节点，然后展开&quot;C/C++&quot;节点，并选择&quot;常规&quot;。 在&quot;附加包含目录&quot;旁边，指定 MathFuncsDll.h 头文件所在位置的路径。 可以
使用相对路径（例如 ..\MathFuncsDll\），然后选择&quot;确定&quot;按钮。5. 现在即可在此应用程序中使用 MyMathFuncs 类。 使用以下代码替换&quot;&quot;的内容：
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>MyExecRefsDll.cpp<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    // MyExecRefsDll.cpp// compile with: /EHsc /link MathFuncsDll.lib</p>
<pre><code>#include &lt;iostream&gt;#include &quot;MathFuncsDll.h&quot;

using namespace std;int main()
{
    double a = 7.4;
    int b = 99;

    cout &lt;&lt; &quot;a + b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Add(a, b) &lt;&lt; endl;
    cout &lt;&lt; &quot;a - b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Subtract(a, b) &lt;&lt; endl;
    cout &lt;&lt; &quot;a * b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Multiply(a, b) &lt;&lt; endl;
    cout &lt;&lt; &quot;a / b = &quot; &lt;&lt;        MathFuncs::MyMathFuncs::Divide(a, b) &lt;&lt; endl;

    try    {
        cout &lt;&lt; &quot;a / 0 = &quot; &lt;&lt;            MathFuncs::MyMathFuncs::Divide(a, 0) &lt;&lt; endl; 
    }
    catch (const invalid_argument &amp;e) 
    {
        cout &lt;&lt; &quot;Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; 
    }

    return 0;
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><img src="" alt=""><br><strong>2. GCC编译、使用静态库</strong><br>foo.h:<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    #ifndef foo_h<strong>#define foo_h</strong></p>
<pre><code>extern void foo(void);
 #endif  // foo_h__
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>foo.c:<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    #include <stdio.h></stdio.h></p>
<pre><code>void foo(void)
{
    puts(&quot;Hello LittleHann, I&apos;m a shared library&quot;);
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>编译动态库文件.so<br>    gcc -shared -Wall -Werror -fpic -o libfoo.so foo.c<br><img src="" alt=""><br>编译好动态库文件之后，我们就可以在其他程序中引入这个动态库文件.so，并使用其中的导出函数<br>main.c:<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    #include <stdio.h>#include “foo.h”</stdio.h></p>
<pre><code>int main(void)
{
    puts(&quot;This is a shared library test...&quot;);
    foo();
    return 0;
}
</code></pre><p><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>在main.c中引入了foo.h头文件<br>    gcc -L. -Wall -o test main.c -lfoo<br><img src="" alt=""><br>编译成功后，还有一件很重要的事，我们回想一下Linux下静态库、动态库的默认搜索顺序<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>    1) LD_LIBRARY_PATH 2) /lib3) /usr/lib  4) /etc/ld.so.cache(使用ldconfig生成的库路径缓存)5) /etc/ld.so.conf文件中添加库的搜索路径6) /etc/ld.so.conf.d下新建一个.conf文件，这种方法可以很灵活地将不同软件的库搜索路径区分开来<br><a href="&quot;复制代码&quot;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>linux是默认不会去搜索当前目录的，所以我们必须将.so文件复制到默认路径下、或者使用LD_LIBRARY_PATH显示指定<br>    cp libfoo.so /usr/lib<br>    ./test<br>    rm -f /usr/lib/libfoo.so<br><img src="" alt=""><br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://msdn.microsoft.com/zh-cn/library/ms235636.aspx" target="_blank" rel="external">http://msdn.microsoft.com/zh-cn/library/ms235636.aspx</a><br>    <a href="http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html" target="_blank" rel="external">http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html</a></p>
<p><strong>5. MinGW简介</strong><br><strong><em>0x1: MinGW是什么</em></strong><br>MinGW(Minimalist GNU for Windows)，又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件(Win32API)、库和可执行文件<br>GCC支持的语言大多在MinGW也受支持，其中涵盖</p>
<pre><code>1. C 2. Objective-C3. Fortran4. Ada5. 对于C语言之外的语言，MinGW使用标准的GNU运行库，如C++使用GNU libstdc++ 
</code></pre><p>但是MinGW使用Windows中的C运行库。因此用MinGW开发的程序不需要额外的第三方DLL支持就可以直接在Windows下运行，而且也不一定必须遵从GPL许可证。这同时造成了MinGW开发的程序只能使用Win32API和跨平台的第三方库，而缺少POSIX支持 ，大多数GNU软件无法在不修改源代码的情况下用MinGW编译<br>GCC是一个原本用于Unix系统下编程的编译器。不过，现在GCC也有了许多Win32下的移植版本，目前GCC在windows下有三个移植版本</p>
<pre><code>1. MinGW2. Cygwin3. Djgpp
</code></pre><p>MinGW是Minimalistic GNU for Windows 的缩写。它是一个建立在GCC和binutils 项目上的编译器系统。和其他GCC的移植版相比，它可以说是最接近Win32的一个了。因为，MinGW几乎支持所有的Win32 API，这也是MinGW的特色之一。它所连接的程序，不需要任何第三方库就可以运行了。在某种程度上看，MinGW更像是VC的替代品<br><strong><em>0x3: MinGW的Linker参数</em></strong><br><strong><em>0x3: 编程示例</em></strong><br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://www.mingw.org/" target="_blank" rel="external">http://www.mingw.org/</a><br>    <a href="https://code.google.com/p/msys-cn/wiki/ChapterThree" target="_blank" rel="external">https://code.google.com/p/msys-cn/wiki/ChapterThree</a><br>    <a href="http://wenku.baidu.com/view/c6f71522af45b307e87197a6.html" target="_blank" rel="external">http://wenku.baidu.com/view/c6f71522af45b307e87197a6.html</a><br><strong>6. CodeBlocks简介</strong><br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://bbs.chinaunix.net/thread-3640636-1-1.html" target="_blank" rel="external">http://bbs.chinaunix.net/thread-3640636-1-1.html</a><br>    <a href="http://zh.wikipedia.org/wiki/Code::Blocks" target="_blank" rel="external">http://zh.wikipedia.org/wiki/Code::Blocks</a><br>    <a href="http://blog.csdn.net/wtfmonking/article/details/17487705" target="_blank" rel="external">http://blog.csdn.net/wtfmonking/article/details/17487705</a></p>
<p><strong><em>Copyright (c) 2014 LittleHann All rights reserved</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/“Git Windows”/" itemprop="url">
                  ????“Git Windows???????????”???
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T21:18:52+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[Git</p>
<ul>
<li>How to use netrc file on windows - Stack Overflow](<a href="http://stackoverflow.com/questions/6031214/git-how-to-use-netrc-file-on-windows" target="_blank" rel="external">http://stackoverflow.com/questions/6031214/git-how-to-use-netrc-file-on-windows</a>)<br><img src="http://img.blog.csdn.net/20150602220505492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></li>
</ul>
<p>这就是正确答案，我们已经验证过了，下面详细描述一下解决方法：</p>
<ol>
<li><p>在Windows中添加一个HOME环境变量，值为%USERPROFILE%，如下图：<br><img src="http://img.blog.csdn.net/20150602220742394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
</li>
<li><p>在“开始》运行”中打开%Home%，新建一个名为“_netrc”的文件。</p>
</li>
<li>用记事本打开_netrc文件，输入Git服务器名、用户名、密码，并保存。示例如下：<br> machine git.cnblogs.com<br> login cnblogs_user<br> password cnblogs_pwd</li>
</ol>
<p>That is the answer, and that is exactly the fucking git!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-08-02T20:12:36+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="HMK" />
          <p class="site-author-name" itemprop="name">HMK</p>
          <p class="site-description motion-element" itemprop="description">学习经验 & 理论知识</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HMK</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
