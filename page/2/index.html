<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://HawkAaron.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://HawkAaron.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-端口占用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/端口占用/" class="article-date">
  <time datetime="2016-08-02T13:18:52.162Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/端口占用/">端口占用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开始–运行–cmd 进入命令提示符 输入netstat -ano 即可看到所有连接的PID 之后在任务管理器中找到这个PID所对应的程序如果任务管理器中<strong>没有PID</strong>这一项,可以在任务管理器中选”查看”-“选择列” </p>
<pre><code>经常，我们在启动应用的时候发现系统需要的端口被别的程序占用，如何知道谁占有了我们需要的端口，很多人都比较头疼，下面就介绍一种非常简单的方法，希望对大家有用 
</code></pre><p>假如我们需要确定谁占用了我们的9050端口 </p>
<p>1、Windows平台<br>在windows命令行窗口下执行：<br>1.查看所有的端口占用情况<br>C:><strong>netstat -ano</strong><br>  协议    本地地址                     外部地址               状态                   PID<br>  TCP    127.0.0.1:1434         0.0.0.0:0              LISTENING       3236<br>  TCP    127.0.0.1:5679         0.0.0.0:0              LISTENING       4168<br>  TCP    127.0.0.1:7438         0.0.0.0:0              LISTENING       4168<br>  TCP    127.0.0.1:8015         0.0.0.0:0              LISTENING       1456<br>  TCP    192.168.3.230:139      0.0.0.0:0              LISTENING       4<br>  TCP    192.168.3.230:1957     220.181.31.225:443     ESTABLISHED     3068<br>  TCP    192.168.3.230:2020     183.62.96.189:1522     ESTABLISHED     1456<br>  TCP    192.168.3.230:2927     117.79.91.18:80        ESTABLISHED     4732<br>  TCP    192.168.3.230:2929     117.79.91.18:80        ESTABLISHED     4732<br>  TCP    192.168.3.230:2930     117.79.91.18:80        ESTABLISHED     4732<br>  TCP    192.168.3.230:2931     117.79.91.18:80        ESTABLISHED     4732</p>
<p>2.查看指定端口的占用情况<br>C:><strong>netstat -aon|findstr “9050”</strong><br>  协议    本地地址                     外部地址               状态                   PID<br>  TCP    127.0.0.1:9050         0.0.0.0:0              LISTENING       2016<br>P: 看到了吗，端口被进程号为2016的进程占用，继续执行下面命令： （也可以去任务管理器中查看pid对应的进程）<br>3.查看PID对应的进程<br>C:><strong>tasklist|findstr “2016”</strong><br> 映像名称                       PID 会话名              会话#       内存使用<br> ========================= ======== ================<br>  tor.exe                     2016 Console                 0     16,064 K </p>
<p>P:很清楚吧，tor占用了你的端口。</p>
<p>4.结束该进程<br>C:><strong>taskkill /f /t /im tor.exe</strong></p>
<p>其他不懂的用 help吧~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/端口占用/" data-id="cirdhs3ev000rv4nr3hxj79ob" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Pythonwin7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/Pythonwin7/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/Pythonwin7/">Python???????win7?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、安装配置Python<br>其实在开发python最好在ubuntu环境下，简单也便于扩展各个package。这次来讲一下如何在win7上搭建Python开发环境。由于python的跨平台性。在windows下和ubuntu下基本上没什么差别。下面从几个不步骤来搭建开发环境。</p>
<p>1.下载（<a href="https://www.python.org/downloads/）安装python.2.7.8" target="_blank" rel="external">https://www.python.org/downloads/）安装python.2.7.8</a>. python有2.7的版本和3.x版本，建议还是使用python-2.7.x 版本，因为python的各大<a href="http://cpro.baidu.com/cpro/ui/uijs.php?app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=e82e61ebfb26f7fc&amp;k=%BF%F2%BC%DC&amp;k0=%BF%F2%BC%DC&amp;kdi0=0&amp;luki=1&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=fcf726fbeb612ee8&amp;ssp2=1&amp;stid=0&amp;t=tpclicked3_hc&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww%2Eth7%2Ecn%2FProgram%2FPython%2F201407%2F245999%2Eshtml&amp;urlid=0" target="_blank" rel="external">框架</a>都支持2.7版本，但是不支持3.x版本。例如简介并且功能强大的webpy<br> 就不支持3.x版本，好像web2py,django 对3.x版本也支持不太好。<br>安装就按照默认安装模式即可，主要是安装完成后设置<a href="http://cpro.baidu.com/cpro/ui/uijs.php?app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=e82e61ebfb26f7fc&amp;k=%BB%B7%BE%B3%B1%E4%C1%BF&amp;k0=%BB%B7%BE%B3%B1%E4%C1%BF&amp;kdi0=0&amp;luki=4&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=fcf726fbeb612ee8&amp;ssp2=1&amp;stid=0&amp;t=tpclicked3_hc&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww%2Eth7%2Ecn%2FProgram%2FPython%2F201407%2F245999%2Eshtml&amp;urlid=0" target="_blank" rel="external">环境变量</a>。python也要配置环境变量，不过比Java简单多了，windows7下：计算机-&gt;属性-&gt;计算机名称、域和工作组设置（更改设置）-&gt;高级-&gt;环境变量，在变量PATH中加入C:/Python27，即之前的安装路径。<br>2.在命令行输入Python，出现下图所示说明安装配置成功。<br><img src="http://img.blog.csdn.net/20150614220256424?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>二、安装配置Pycharm IDE开发工具<br>在python的开发过程中，刚开始一直没找到像eclipse 那样的方便的<a href="http://cpro.baidu.com/cpro/ui/uijs.php?app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=e82e61ebfb26f7fc&amp;k=%BF%AA%B7%A2%B9%A4%BE%DF&amp;k0=%BF%AA%B7%A2%B9%A4%BE%DF&amp;kdi0=0&amp;luki=5&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=fcf726fbeb612ee8&amp;ssp2=1&amp;stid=0&amp;t=tpclicked3_hc&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww%2Eth7%2Ecn%2FProgram%2FPython%2F201407%2F245999%2Eshtml&amp;urlid=0" target="_blank" rel="external">开发工具</a>，大部分网友估计用过ecplise的pydev插件。其实早期学习的python过程，确实也用过这个工具。但是最终发现这个pycharm后，果断的放弃eclipse，因为它太好用啦。<br> PyCharm 是我用过的python编辑器中，比较顺手的一个。而且可以跨平台，在macos和windows下面都可以用，这点比较好。<br> pycharm的官方下载地址： <a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="external">http://www.jetbrains.com/pycharm/</a><br> 我们可以下载free的社区版，这足够我们用了。安装按照默认安装即可，安装成功启动如下：代表安装成功。<br>首先预览一下 PyCharm 在实际应用中的界面：<br><img src="http://img.blog.csdn.net/20150614220848906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>PyCharm 的激活方式：<br>1，推荐购买正版。<br>2，可以选择试用，免费试用30天。<br>3，网上找激活码：<br>用户名：yueting3527<br>注册码：<br>===== LICENSE BEGIN =====<br>93347-12042010<br>00001FMHemWIs”6wozMZnat3IgXKXJ<br>2!nV2I6kSO48hgGLa9JNgjQ5oKz1Us<br>FFR8k”nGzJHzjQT6IBG!1fbQZn9!Vi<br>===== LICENSE END =====<br>三、Pycharm的使用<br>1,点击Create New Project.<br>2, 输入项目名、路径、选择python解释器。如果没有出现python解释器，进入步骤3.<br><img src="http://img.blog.csdn.net/20150614221056309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>3，选择<a href="http://cpro.baidu.com/cpro/ui/uijs.php?app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=e82e61ebfb26f7fc&amp;k=python&amp;k0=python&amp;kdi0=0&amp;luki=7&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=fcf726fbeb612ee8&amp;ssp2=1&amp;stid=0&amp;t=tpclicked3_hc&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww%2Eth7%2Ecn%2FProgram%2FPython%2F201407%2F245999%2Eshtml&amp;urlid=0" target="_blank" rel="external">python</a>解释器。可以看到，一旦添加了python解释器，pycharm就会扫描出你已经安装的python扩展包，和这些扩展包的最新版本。<br>4，点击OK之后，就会创建一个空项目，里面包含一个.idea的文件夹，用于pycharm管理项目。<br>5，新建一个文件：右键单击刚建好的helloWord项目，选择New –&gt; Python File<br><img src="http://img.blog.csdn.net/20150614221428207?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>6，输入文件名：输入文件名，没什么好说的<br><img src="http://img.blog.csdn.net/20150614221552477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>7，进入编写界面：PyCharm的默认编辑界面很怪，会自动生成一行 <strong>author</strong> = “作者” 的头。而比较常用的文件头，如：#coding=utf-8 等，反倒没有自动生成。<br><img src="http://img.blog.csdn.net/20150614221724802?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>输入code：print “Hello word!”<br><img src="http://img.blog.csdn.net/20150614221923517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>8，设置<a href="http://cpro.baidu.com/cpro/ui/uijs.php?app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=e82e61ebfb26f7fc&amp;k=%BF%D8%D6%C6%CC%A8&amp;k0=%BF%D8%D6%C6%CC%A8&amp;kdi0=0&amp;luki=3&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=fcf726fbeb612ee8&amp;ssp2=1&amp;stid=0&amp;t=tpclicked3_hc&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww%2Eth7%2Ecn%2FProgram%2FPython%2F201407%2F245999%2Eshtml&amp;urlid=0" target="_blank" rel="external">控制台</a>：运行之前，我们发现快捷菜单上的【运行】和【调试】都是灰色的，不可触发状态。是因为，我们需要先配置一下控制台。点击运行旁边的黑色倒三角，进入【Run/Debug<br> Configurations】配置界面。（或者点击Run –&gt; Edit Configurations 也一样）<br><img src="http://img.blog.csdn.net/20150614222121670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>在【Run/Debug Configurations】配置界面里，点击绿色的加号，新建一个配置项，并选择<a href="http://cpro.baidu.com/cpro/ui/uijs.php?app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=e82e61ebfb26f7fc&amp;k=python&amp;k0=python&amp;kdi0=0&amp;luki=7&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=fcf726fbeb612ee8&amp;ssp2=1&amp;stid=0&amp;t=tpclicked3_hc&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww%2Eth7%2Ecn%2FProgram%2FPython%2F201407%2F245999%2Eshtml&amp;urlid=0" target="_blank" rel="external">python</a>。（因为hello<br> word 就是个python程序）<br><img src="http://img.blog.csdn.net/20150614222249308?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>在右边的配置界面里：Name 一栏里写个名字，比如Hello。点击Scrip选项，找到刚才我们写的hello_word.py<br><img src="http://img.blog.csdn.net/20150614222438443?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>点击ok, 自动返回到编辑界面，这时候【运行】【调试】按钮全部变绿！<br><img src="http://img.blog.csdn.net/20150614222535224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>9，运行：点击绿色的运行<a href="http://cpro.baidu.com/cpro/ui/uijs.php?app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=e82e61ebfb26f7fc&amp;k=%B0%B4%C5%A5&amp;k0=%B0%B4%C5%A5&amp;kdi0=0&amp;luki=2&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=fcf726fbeb612ee8&amp;ssp2=1&amp;stid=0&amp;t=tpclicked3_hc&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww%2Eth7%2Ecn%2FProgram%2FPython%2F201407%2F245999%2Eshtml&amp;urlid=0" target="_blank" rel="external">按钮</a>，观看输出的结果：<br><img src="http://img.blog.csdn.net/20150614222630525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>到此，Python开发环境搭建完成，第一个Python工程已经成功运行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/Pythonwin7/" data-id="cirdhs3dd000bv4nrijwbrt0t" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-oracle审计详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/oracle审计详解/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/oracle审计详解/">oracle审计详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Oracle使用大量不同的审计方法来监控使用何种权限，以及访问哪些对象。审计不会防止使用这些权限，但可以提供有用的信息，用于揭示权限的滥用和误用。<br>下表中总结了Oracle数据库中不同类型的审计。<br>审 计 类 型<br>说    明<br>语句审计<br>按照语句类型审计SQL语句，而不论访问何种特定的模式对象。也可以在数据库中指定一个或多个用户，针对特定的语句审计这些用户<br>权限审计<br>审计系统权限，例如CREATE TABLE或ALTER INDEX。和语句审计一样，权限审计可以指定一个或多个特定的用户作为审计的目标<br>模式对象审计<br>审计特定模式对象上运行的特定语句(例如，DEPARTMENTS表上的UPDATE语句)。模式对象审计总是应用于数据库中的所有用户<br>细粒度的审计<br>根据访问对象的内容来审计表访问和权限。使用程序包DBMS_FGA来建立特定表上的策略<br>下面几节介绍DBA如何管理系统和对象权限使用的审计。当需要一定的粒度时，DBA可以使用细粒度的审计来监控对表中某些行或列的访问，而不仅仅是是否访问表。<br>和审计相关的主要参数<br>SQL&gt;show parameter audit<br>audit_file_dest<br>audit_sys_operations<br>audit_trail</p>
<p>audit_sys_operations：<br>默认为false，当设置为true时，所有sys用户（包括以sysdba,sysoper身份登录的用户）的操作都会被记录，audit trail不会写在aud$表中，这个很好理解，如果数据库还未启动aud$不可用，那么像conn /as sysdba这样的连接信息，只能记录在其它地方。如果是windows平台，audti trail会记录在windows的事件管理中，如果是linux/unix平台则会记录在audit_file_dest参数指定的文件中。</p>
<p>audit_trail：<br>None：是默认值，不做审计；<br>DB：将audit trail 记录在数据库的审计相关表中，如aud$，审计的结果只有连接信息；<br>DB,Extended：这样审计结果里面除了连接信息还包含了当时执行的具体语句；<br>OS：将audit trail 记录在操作系统文件中，文件名由audit_file_dest参数指定；<br>XML：10g里新增的。<br>10g Values:</p>
<ul>
<li><p><code>none</code><br>Disables database auditing.</p>
</li>
<li><p><code>os</code><br>Enables database auditing and directs all audit records to the operating system’s audit trail.</p>
</li>
<li><p><code>db</code><br>Enables database auditing and directs all audit records to the database audit trail (the <code>SYS.AUD$</code> table).</p>
</li>
<li><p><code>db,extended</code><br>Enables database auditing and directs all audit records to the database audit trail (the <code>SYS.AUD$</code> table). In addition, populates<br>the <code>SQLBIND</code> and <code>SQLTEXT</code> CLOB columns of the <code>SYS.AUD$</code> table.</p>
</li>
<li><p><code>xml</code><br>Enables database auditing and writes all audit records to XML format OS files.</p>
</li>
<li><p><code>xml``,extended</code><br>Enables database auditing and prints all columns of the audit trail, including SqlText and SqlBind values.</p>
</li>
</ul>
<p>注：参数AUDIT_TRAIL不是动态的，为了使AUDIT_TRAIL参数中的改动生效，必须关闭数据库并重新启动。在对SYS.AUD$表进行审计时，应该注意监控该表的大小，以避免影响SYS表空间中其他对象的空间需求。推荐周期性归档SYS.AUD$中的行，并且截取该表。Oracle提供了角色 DELETE_CATALOG_ROLE，和批处理作业中的特殊账户一起使用，用于归档和截取审计表。<br>audit_file_dest：Audit_trail=OS时 文件位置<br><strong>1.语句审计</strong><br>所有类型的审计都使用audit命令来打开审计，使用noaudit命令来关闭审计。对于语句审计，audit命令的格式看起来如下所示：<br>    AUDIT sql_statement_clause BY {SESSION | ACCESS}<br>    WHENEVER [NOT] SUCCESSFUL;</p>
<p>sql_statement_clause包含很多条不同的信息，例如希望审计的SQL语句类型以及审计什 么人。<br>此外，希望在每次动作发生时都对其进行审计(by access)或者只审计一次(by session)。默认是by session。<br>有时希望审计成功的动作：没有生成错误消息的语句。对于这些语句，添加whenever successful。而有时只关心使用审计语句的命令是否失败，失败原因是权限违犯、用完表空间中的空间还是语法错误。对于这些情况，使用 whenever not successful。<br>对于大多数类别的审计方法，如果确实希望审计所有类型的表访问或某个用户的任何权限，则可以指定all而不是单个的语句类型或对象。<br>表1列出了可以审计的语句类型，并且在每个类别中包含了相关语句的简要描述。如果指定all，则审计该列表中的任何语句。然而，表2中的语句类型在启用审计时不属于all类别；必须在audit命令中显式地指定它们。<br>表1 包括在ALL类别中的可审计语句<br>语 句 选 项<br>SQL操作<br>ALTER SYSTEM<br>所有ALTER SYSTEM选项，例如，动态改变实例参数，切换到下一个日志文件组，以及终止用户会话<br>CLUSTER<br>CREATE、ALTER、DROP或TRUNCATE集群<br>CONTEXT<br>CREATE CONTEXT或DROP CONTEXT<br>DATABASE LINK<br>CREATE或DROP数据库链接<br>DIMENSION<br>CREATE、ALTER或DROP维数<br>DIRECTORY<br>CREATE或DROP目录<br>INDEX<br>CREATE、ALTER或DROP索引<br>MATERIALIZED VIEW<br>CREATE、ALTER或DROP物化视图<br>NOT EXISTS<br>由于不存在的引用对象而造成的SQL语句的失败<br>PROCEDURE<br>CREATE或DROP FUNCTION、LIBRARY、PACKAGE、PACKAGE BODY或PROCEDURE<br>PROFILE<br>CREATE、ALTER或DROP配置文件<br>PUBLIC DATABASE LINK<br>CREATE或DROP公有数据库链接<br>PUBLIC SYNONYM<br>CREATE或DROP公有同义词<br>ROLE<br>CREATE、ALTER、DROP或SET角色<br>ROLLBACK SEGMENT<br>CREATE、ALTER或DROP回滚段<br>SEQUENCE<br>CREATE或DROP序列<br>SESSION<br>登录和退出<br>SYNONYM<br>CREATE或DROP同义词<br>SYSTEM AUDIT<br>系统权限的AUDIT或NOAUDIT<br>SYSTEM GRANT<br>GRANT或REVOKE系统权限和角色<br>TABLE<br>CREATE、DROP或TRUNCATE表<br>TABLESPACE<br>CREATE、ALTER或DROP表空间<br>TRIGGER<br>CREATE、ALTER(启用/禁用)、DROP触发器；具有ENABLE ALL TRIGGERS或DISABLE ALL TRIGGERS的ALTER TABLE<br>TYPE<br>CREATE、ALTER和DROP类型以及类型主体<br>USER<br>CREATE、ALTER或DROP用户<br>VIEW<br>CREATE或DROP视图<br>表2 显式指定的语句类型<br>语 句 选 项<br>SQL 操 作<br>ALTER SEQUENCE<br>任何ALTER SEQUENCE命令<br>ALTER TABLE<br>任何ALTER TABLE命令<br>COMMENT TABLE<br>添加注释到表、视图、物化视图或它们中的任何列<br>DELETE TABLE<br>删除表或视图中的行<br>EXECUTE PROCEDURE<br>执行程序包中的过程、函数或任何变量或游标<br>GRANT DIRECTORY<br>GRANT或REVOKE DIRECTORY对象上的权限<br>GRANT PROCEDURE<br>GRANT或REVOKE过程、函数或程序包上的权限<br>GRANT SEQUENCE<br>GRANT或REVOKE序列上的权限<br>GRANT TABLE<br>GRANT或REVOKE表、视图或物化视图上的权限<br>GRANT TYPE<br>GRANT或REVOKE TYPE上的权限<br>INSERT TABLE<br>INSERT INTO表或视图<br>LOCK TABLE<br>表或视图上的LOCK TABLE命令<br>SELECT SEQUENCE<br>引用序列的CURRVAL或NEXTVAL的任何命令<br>SELECT TABLE<br>SELECT FROM表、视图或物化视图<br>UPDATE TABLE<br>在表或视图上执行UPDATE<br>一些示例可以帮助读者更清楚地了解所有这些选项。在示例数据库中，用户KSHELTON具有HR模式和其他模式中所有表上的权限。允许 KSHELTON创建其中一些表上的索引，但如果有一些与执行计划改动相关的性能问题，则需要知道何时创建这些索引。可以使用如下命令审计 KSHELTON创建的索引：<br>    SQL&gt; audit index by kshelton;<br>    Audit succeeded.</p>
<p>后面的某一天，KSHELTON在HR.JOBS表上创建了一个索引：<br>    SQL&gt; create index job_title_idx on hr.jobs(job_title);<br>    Index created.<br>检查数据字典视图DBA_AUDIT_TRAIL中的审计跟踪，可以看到KSHELTON实际上在8月12日的5:15 P.M.创建了索引：<br>    SQL&gt; select username, to_char(timestamp,’MM/DD/YY HH24:MI’) Timestamp,<br>    2      obj_name, action_name, sql_text from dba_audit_trail<br>    3  where username = ‘KSHELTON’;<br>    USERNAME    TIMESTAMP        OBJ_NAME         ACTION_NAME      SQL_TEXT</p>
<pre><code>---------  --------------  --------------  --------------  ----------------
KSHELTON    08/12/07 17:15  JOB_TITLE_IDX   CREATE INDEX     create index hr.
job_title_idx on
hr.jobs(job_title)
1 row selected.
</code></pre><p>注意：<br>从Oracle Database 11g开始，只有在初始参数AUDIT_TRAIL被设置为DB_EXTENDED时，才填充DBA_AUDIT_TRAIL中的列SQL_TEXT和SQL_BIND。默认情况下，AUDIT_TRAIL的值是DB。<br>为了关闭HR.JOBS表上KSHELTON的审计，可以使用noaudit命令，如下所示：<br>    SQL&gt; noaudit index by kshelton;<br>    Noaudit succeeded.<br>也可能希望按常规方式审计成功的和不成功的登录，这需要两个audit命令：<br>    SQL&gt; audit session whenever successful;<br>    Audit succeeded.<br>    SQL&gt; audit session whenever not successful;<br>    Audit succeeded.</p>
<p><strong>2.权限审计</strong><br>审计系统权限具有与语句审计相同的基本语法，但审计系统权限是在sql_statement_clause中，而不是在语句中，指定系统权限。<br>例如，可能希望将ALTER TABLESPACE权限授予所有的DBA，但希望在发生这种情况时生成审计记录。启用对这种权限的审计的命令看起来类似于语句审计：<br>    SQL&gt; audit alter tablespace by access whenever successful;<br>    Audit succeeded.<br>每次成功使用ALTER TABLESPACE权限时，都会将一行内容添加到SYS.AUD$。<br>使用SYSDBA和SYSOPER权限或者以SYS用户连接到数据库的系统管理员可以利用特殊的审计。为了启用这种额外的审计级别，可以设置初始参数AUDIT_SYS_OPERATIONS为TRUE。这种审计记录发送到与操作系统审计记录相同的位置。因此，这个位置是和操作系统相关的。当使用其中一种权限时执行的所有SQL语句，以及作为用户SYS执行的任何SQL语句，都会发送到操作系统审计位置。<br>模式对象审计<br>审计对各种模式对象的访问看起来类似于语句审计和权限审计：<br>    AUDIT schema_object_clause BY {SESSION | ACCESS}<br>    WHENEVER [NOT] SUCCESSFUL;</p>
<p>schema_object_clause指定对象访问的类型以及访问的对象。可以审计特定对象上14种不同的操作类型，下表中列出了这些操作。<br>对 象 选 项<br>说    明<br>ALTER<br>改变表、序列或物化视图<br>AUDIT<br>审计任何对象上的命令<br>COMMENT<br>添加注释到表、视图或物化视图<br>DELETE<br>从表、视图或物化视图中删除行<br>EXECUTE<br>执行过程、函数或程序包<br>FLASHBACK<br>执行表或视图上的闪回操作<br>GRANT<br>授予任何类型对象上的权限<br>INDEX<br>创建表或物化视图上的索引<br>INSERT<br>将行插入表、视图或物化视图中<br>LOCK<br>锁定表、视图或物化视图<br>READ<br>对DIRECTORY对象的内容执行读操作<br>RENAME<br>重命名表、视图或过程<br>SELECT<br>从表、视图、序列或物化视图中选择行<br>UPDATE<br>更新表、视图或物化视图<br>如果希望审计HR.JOBS表上的所有insert和update命令，而不管谁正在进行更新，则每次该动作发生时，都可以使用如下所示的audit命令：<br>    SQL&gt; audit insert, update on hr.jobs by access whenever successful;<br>    Audit successful.<br>用户KSHELTON决定向HR.JOBS表添加两个新行：<br>    SQL&gt; insert into hr.jobs (job_id, job_title, min_salary, max_salary)<br>    2  values (‘IN_CFO’,’Internet Chief Fun Officer’, 7500, 50000);<br>    1 row created.<br>    SQL&gt; insert into hr.jobs (job_id, job_title, min_salary, max_salary)<br>    2  values (‘OE_VLD’,’Order Entry CC Validation’, 5500, 20000);<br>    1 row created.<br>查看DBA_AUDIT_TRAIL视图，可以看到KSHELTON会话中的两个insert命令：<br>    USERNAME   TIMESTAMP      OWNER    OBJ_NAME   ACTION_NAME<br>    SQL_TEXT</p>
<pre><code>---------- -------------- -------- ---------- ---------------
---------------------------------------------------------------
KSHELTON   08/12/07 22:54 HR       JOBS       INSERT
insert into hr.jobs (job_id, job_title, min_salary, max_salary)
values (&apos;IN_CFO&apos;,&apos;Internet Chief Fun Officer&apos;, 7500, 50000);
KSHELTON   08/12/07 22:53 HR       JOBS       INSERT
insert into hr.jobs (job_id, job_title, min_salary, max_salary)
values (&apos;OE_VLD&apos;,&apos;Order Entry CC Validation&apos;, 5500, 20000);
KSHELTON   08/12/07 22:51                     LOGON
</code></pre><p>3 rows selected.</p>
<p><strong>4.细粒度的审计</strong><br>从Oracle9i开始，通过引入细粒度的对象审计，或称为FGA，审计变得更为关注某个方面，并且更为精确。由称为DBMS_FGA的PL/SQL程序包实现FGA。<br>使用标准的审计，可以轻松发现访问了哪些对象以及由谁访问，但无法知道访问了哪些行或列。细粒度的审计可解决这个问题，它不仅为需要访问的行指定谓词(或where子句)，还指定了表中访问的列。通过只在访问某些行和列时审计对表的访问，可以极大地减少审计表条目的数量。<br>程序包DBMS_FGA具有4个过程：<br>ADD_POLICY<br>添加使用谓词和审计列的审计策略<br>DROP_POLICY<br>删除审计策略<br>DISABLE_POLICY<br>禁用审计策略，但保留与表或视图关联的策略<br>ENABLE_POLICY<br>启用策略<br>用户TAMARA通常每天访问HR.EMPLOYEES表，查找雇员的电子邮件地址。系统管理员怀疑TAMARA正在查看经理们的薪水信息，因此他们建立一个FGA策略，用于审计任何经理对SALARY列的任何访问：<br>    begin<br>    dbms_fga.add_policy(<br>    object_schema =&gt;   ‘HR’,<br>    object_name =&gt;     ‘EMPLOYEES’,<br>    policy_name =&gt;     ‘SAL_SELECT_AUDIT’,<br>    audit_condition =&gt; ‘instr(job_id,’’_MAN’’) &gt; 0’,<br>    audit_column =&gt;    ‘SALARY’<br>    );<br>    end;<br>可以使用数据字典视图DBA_FGA_AUDIT_TRAIL访问细粒度审计的审计记录。如果一般需要查看标准的审计行和细粒度的审计行，则数据字典视图DBA_COMMON_AUDIT_TRAIL结合了这两种审计类型中的行。<br>继续看示例，用户TAMARA运行了如下两个SQL查询：<br>    SQL&gt; select employee_id, first_name, last_name, email from hr.employees<br>    2     where employee_id = 114;<br>    EMPLOYEE_ID FIRST_NAME           LAST_NAME                 EMAIL</p>
<pre><code>----------- ------------------ ---------------------   --------------
114    Den                   Raphaely                  DRAPHEAL
1 row selected.
SQL&gt; select employee_id, first_name, last_name, salary from hr.employees
2     where employee_id = 114;
EMPLOYEE_ID FIRST_NAME           LAST_NAME                     SALARY
----------- ------------------ -----------------------   ----------
114    Den                   Raphaely                       11000
1 row selected.
</code></pre><p>第一个查询访问经理信息，但没有访问SALARY列。第二个查询与第一个查询相同，但是访问了SALARY列，因此触发了FGA策略，从而在审计跟踪中生成了一行：<br>    SQL&gt; select to_char(timestamp,’mm/dd/yy hh24:mi’) timestamp,<br>    2      object_schema, object_name, policy_name, statement_type<br>    3  from dba_fga_audit_trail<br>    4  where db_user = ‘TAMARA’;<br>    TIMESTAMP        OBJECT_SCHEMA  OBJECT_NAME     POLICY_NAME       STATEMENT_TYPE</p>
<pre><code>--------------  -------------  -------------  ---------------- --------------
08/12/07 18:07  HR               EMPLOYEES       SAL_SELECT_AUDIT SELECT
1 row selected.
</code></pre><p>因为在本章前面的VPD示例中建立了细粒度的访问控制来阻止对SALARY列的未授权访问，因此需要加倍检查策略函数，确保仍然正确限制了SALARY信息。细粒度的审计以及标准审计是确保首先正确建立授权策略的好方法。<br><strong>5.与审计相关的数据字典视图</strong><br>下表包含了与审计相关的数据字典视图。<br>数据字典视图<br>说    明<br>AUDIT_ACTIONS<br>包含审计跟踪动作类型代码的描述，例如INSERT、DROP VIEW、DELETE、LOGON和LOCK<br>DBA_AUDIT_OBJECT<br>与数据库中对象相关的审计跟踪记录<br>DBA_AUDIT_POLICIES<br>数据库中的细粒度审计策略<br>DBA_AUDIT_SESSION<br>与CONNECT和DISCONNECT相关的所有审计跟踪记录<br>DBA_AUDIT_STATEMENT<br>与GRANT、REVOKE、AUDIT、NOAUDIT和ALTER SYSTEM命令相关的审计跟踪条目<br>DBA_AUDIT_TRAIL<br>包含标准审计跟踪条目。USER_AUDIT_TRAILUSER_TRAIL_AUDIT只包含已连接用户的审计行<br>DBA_FGA_AUDIT_TRAIL<br>细粒度审计策略的审计跟踪条目</p>
<pre><code>(续表)  
</code></pre><p>数据字典视图<br>说    明<br>DBA_COMMON_AUDIT_TRAIL<br>将标准的审计行和细粒度的审计行结合在一个视图中<br>DBA_OBJ_AUDIT_OPTS<br>对数据库对象生效的审计选项<br>DBA_PRIV_AUDIT_OPTS<br>对系统权限生效的审计选项<br>DBA_STMT_AUDIT_OPTS<br>对语句生效的审计选项</p>
<p><strong>6.保护审计跟踪</strong><br>审计跟踪自身需要受到保护，特别是在非系统用户必须访问表SYS.AUD$时。内置的角色DELETE_ANY_CATALOG是非SYS用户可以访问审计跟踪的一种方法(例如，归档和截取审计跟踪，以确保它不会影响到SYS表空间中其他对象的空间需求)。<br>为了建立对审计跟踪自身的审计，以SYSDBA身份连接到数据库，并运行下面的命令：<br>    SQL&gt; audit all on sys.aud$ by access;<br>    Audit succeeded.<br>现在，所有针对表SYS.AUD$的动作，包括select、insert、update和delete，都记录在SYS.AUD$自身中。但是，您可能会问，如果某个人删除了标识对表SYS.AUD$访问的审计记录，这时会发生什么？此时将删除表中的行，但接着插入另一行，记录行的删除。因此，总是存在一些针对SYS.AUD$表的(有意的或偶然的)活动的证据。此外，如果将AUDIT_SYS _OPERATIONS设置为True，使用as sysdba、as sysoper或以SYS自身连接的任何会话将记录到操作系统审计位置中，甚至Oracle<br> DBA可能都无法访问该位置。因此，有许多合适的安全措施，用于确保记录数据库中所有权限的活动，以及隐藏该活动的任何尝试。<br><strong>7.启用增强的审计</strong><br>从Oracle Database 11g开始，数据库配置助手(Database Configuration Assistant，DBCA)很容易启用默认的(增强的)审计。虽然记录审计信息有一些系统开销，但兼容性需求(例如，Sarbanes-Oxley法案中规定的兼容性需求)要求严格监控所有业务操作，包括数据库中与安全相关的操作。<br>可以在创建数据库时或在数据库已经创建之后使用DBCA配置默认审计。如果已经改变了很多审计设置，并想要将审计选项重置为基线值，则在数据库已创建之后使用DBCA配置默认审计就非常有用。<br>除将初始参数AUDIT_TRAIL的值设置为DB外，默认审计设置还审计audit role命令本身。另外，在Audited Privileges选项卡的Oracle Enterprise Manager Audit Settings页面中，可以查看默认的审计权限。<br>补充说明：<br><strong>8、实例讲解</strong></p>
<p>8.1、激活审计<br>审计相关的表安装</p>
<p>  SQLPLUS&gt; connect / AS SYSDBA<br>  SQLPLUS&gt; select <em> from sys.aud$;     –没有记录返回<br>  SQLPLUS&gt; select </em> from dba_audit_trail;   - 没有记录返回<br> 如果做上述查询的时候发现表不存在，说明审计相关的表还没有安装，需要安装。</p>
<p>  SQLPLUS&gt; connect / as sysdba<br>  SQLPLUS&gt; @$ORACLE_HOME/rdbms/admin/cataudit.sql<br> 审计表安装在SYSTEM表空间。所以要确保SYSTEM表空间又足够的空间存放审计信息。<br>   安装后要重启数据库</p>
<p>将审计相关的表移动到其他表空间</p>
<p>由于AUD$表等审计相关的表存放在SYSTEM表空间，因此为了不影响系统的性能，保护SYSTEM表空间，最好把AUD$移动到其他的表空间上。可以使用下面的语句来进行移动：</p>
<p>sql&gt;connect / as sysdba;<br>sql&gt;alter table aud$ move tablespace <new tablespace="">;<br>sql&gt;alter index I_aud1 rebuild online tablespace <new tablespace="">;<br>SQL&gt; alter table audit$ move tablespace <new tablespace="">;<br>SQL&gt; alter index i_audit rebuild online tablespace <new tablespace="">;<br>SQL&gt; alter table audit_actions move tablespace <new tablespace="">;<br>SQL&gt; alter index i_audit_actions rebuild online tablespace <new tablespace="">;</new></new></new></new></new></new></p>
<p>SQL&gt; conn /as sysdba<br>SQL&gt; show parameter audit<br>NAME                                 TYPE        VALUE</p>
<hr>
<p>audit_file_dest                      string      /u01/app/oracle/admin/ORCL/adump<br>audit_sys_operations                 boolean     FALSE<br>audit_syslog_level                   string<br>audit_trail                          string      NONE</p>
<p>SQL&gt; alter system set audit_sys_operations=TRUE scope=spfile;    –审计管理用户(以sysdba/sysoper角色登陆)<br>SQL&gt; alter system set audit_trail=db,extended scope=spfile;<br>SQL&gt; startup force;<br>SQL&gt; show parameter audit<br>NAME                                 TYPE        VALUE</p>
<hr>
<p>audit_file_dest                      string      /u01/app/oracle/admin/ORCL/adump<br>audit_sys_operations                 boolean     TRUE<br>audit_syslog_level                   string<br>audit_trail                          string      DB, EXTENDED          </p>
<p>8.2、开始审计</p>
<p>SQL&gt; conn /as sysdba<br>SQL&gt; audit all on t_test;<br>SQL&gt; conn u_test<br>SQL&gt; select * from t_test;<br>SQL&gt; insert into u_test.t_test (c2,c5) values (‘test1’,’2’);<br>SQL&gt; commit;<br>SQL&gt; delete from u_test.t_test;<br>SQL&gt; commit;<br>SQL&gt; conn /as sysdba<br>SQL&gt; col DEST_NAME format a30<br>col OS_USERNAME format a15<br>col USERNAME format a15<br>col USERHOST format a15<br>col TERMINAL format a15<br>col OBJ_NAME format a30<br>col SQL_TEXT format a60<br>SQL&gt; select OS_USERNAME,username,USERHOST,TERMINAL,TIMESTAMP,OWNER,obj_name,ACTION_NAME,sessionid,os_process,sql_text from dba_audit_trail;</p>
<p>sql&gt; audit select table by u_test by access;<br>如果在命令后面添加by user则只对user的操作进行审计,如果省去by用户,则对系统中所有的用户进行审计(不包含sys用户).</p>
<p>例：<br>AUDIT DELETE ANY TABLE;    –审计删除表的操作<br>AUDIT DELETE ANY TABLE WHENEVER NOT SUCCESSFUL;    –只审计删除失败的情况<br>AUDIT DELETE ANY TABLE WHENEVER SUCCESSFUL;    –只审计删除成功的情况<br>AUDIT DELETE,UPDATE,INSERT ON user.table by test;    –审计test用户对表user.table的delete,update,insert操作</p>
<p>8.3、撤销审计<br>SQL&gt; noaudit all on t_test;</p>
<p><strong>9、审计语句</strong></p>
<p>多层环境下的审计：appserve-应用服务器，jackson-client<br>AUDIT SELECT TABLE BY appserve ON BEHALF OF jackson;</p>
<p>审计连接或断开连接：<br>AUDIT SESSION;<br>AUDIT SESSION BY jeff, lori;    – 指定用户</p>
<p>审计权限(使用该权限才能执行的操作)：<br>AUDIT DELETE ANY TABLE BY ACCESS WHENEVER NOT SUCCESSFUL;<br>AUDIT DELETE ANY TABLE;<br>AUDIT SELECT TABLE, INSERT TABLE, DELETE TABLE, EXECUTE PROCEDURE BY ACCESS WHENEVER NOT SUCCESSFUL;</p>
<p>对象审计：<br>AUDIT DELETE ON jeff.emp;<br>AUDIT SELECT, INSERT, DELETE ON jward.dept BY ACCESS WHENEVER SUCCESSFUL;</p>
<p>取消审计：<br>NOAUDIT session;<br>NOAUDIT session BY jeff, lori;<br>NOAUDIT DELETE ANY TABLE;<br>NOAUDIT SELECT TABLE, INSERT TABLE, DELETE TABLE,EXECUTE PROCEDURE;<br>NOAUDIT ALL;    – 取消所有statement审计<br>NOAUDIT ALL PRIVILEGES;    – 取消所有权限审计<br>NOAUDIT ALL ON DEFAULT;    – 取消所有对象审计</p>
<p><strong>10、清除审计信息</strong></p>
<p>DELETE FROM SYS.AUD$;<br>DELETE FROM SYS.AUD$ WHERE obj$name=’EMP’;</p>
<p><strong>11、审计视图</strong></p>
<p>STMT_AUDIT_OPTION_MAP    – 审计选项类型代码<br>AUDIT_ACTIONS    – action代码<br>ALL_DEF_AUDIT_OPTS    – 对象创建时默认的对象审计选项<br>DBA_STMT_AUDIT_OPTS    – 当前数据库系统审计选项<br>DBA_PRIV_AUDIT_OPTS    – 权限审计选项<br>DBA_OBJ_AUDIT_OPTS<br>USER_OBJ_AUDIT_OPTS    – 对象审计选项<br>DBA_AUDIT_TRAIL<br>USER_AUDIT_TRAIL    – 审计记录<br>DBA_AUDIT_OBJECT<br>USER_AUDIT_OBJECT    – 审计对象列表<br>DBA_AUDIT_SESSION<br>USER_AUDIT_SESSION    – session审计<br>DBA_AUDIT_STATEMENT<br>USER_AUDIT_STATEMENT    – 语句审计<br>DBA_AUDIT_EXISTS    – 使用BY AUDIT NOT EXISTS选项的审计<br>DBA_AUDIT_POLICIES    – 审计POLICIES<br>DBA_COMMON_AUDIT_TRAIL    – 标准审计+精细审计</p>
<p><strong>12、将审计结果表从system表空间里移动到别的表空间上</strong></p>
<p>实际上sys.aud$表上包含了两个lob字段，并不是简单的move table就可以。<br>下面是具体的过程:<br>alter table sys.aud$ move tablespace users;<br>alter table sys.aud$ move lob(sqlbind) store as( tablespace USERS);<br>alter table sys.aud$ move lob(SQLTEXT) store as( tablespace USERS);<br>alter index sys.I_AUD1 rebuild tablespace users;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/oracle审计详解/" data-id="cirdhs3dz000hv4nre44i32i5" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-proteus解决LED二极管不发光问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/proteus解决LED二极管不发光问题/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/proteus解决LED二极管不发光问题/">proteus解决LED二极管不发光问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://img.blog.csdn.net/20150607130238443?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>如上图，LED正接不亮，这种情况是LED和电阻之间没有导线连接造成的（一般元件之间必须要有导线连接，如果直接把元件拖到后面，看起来接上去了，其实是断开的）<br><img src="http://img.blog.csdn.net/20150607130353831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>拖动电阻，发现的确没有连接<br><img src="http://img.blog.csdn.net/20150607130443096?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>连接后LED正常</p>
<p>也许你会发现连线正常后LED依然不亮，这时你应该注意一下电阻值的设定<br><img src="http://img.blog.csdn.net/20150607130632281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>如上图，5k的阻值，LED不亮了<br><img src="http://img.blog.csdn.net/20150607130931719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA0ODA2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>阻值设为2k时很暗，这说明阻值高了，一般我们设置为100或200</p>
<p>最后，如果你发现连接正常并且电阻值很低时LED还是不亮，那很可能是你的LED接反了，注意图中的接法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/proteus解决LED二极管不发光问题/" data-id="cirdhs3e0000iv4nr6iahblq1" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-oracle查看当前登陆的用户信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/oracle查看当前登陆的用户信息/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/oracle查看当前登陆的用户信息/">oracle查看当前登陆的用户信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>查看当前登陆的用户名：<br>select user from dual;<br>或者<br>select * from user_users;<br>或者<br>show user</p>
<p>查看当前用户拥有的角色和权限：<br>select <em> from user_role_privs;<br>select </em> from session_privs;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/oracle查看当前登陆的用户信息/" data-id="cirdhs3e0000jv4nrboap4mal" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python编写带参数decorator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/Python编写带参数decorator/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/Python编写带参数decorator/">Python编写带参数decorator</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> @log 装饰器：<br>    def log(f):<br>        def fn(x):<br>            print ‘call ‘ + f.<strong>name</strong> + ‘()…’<br>            return f(x)<br>        return fn<br>对于被装饰的函数，log打印的语句是不能变的（除了函数名）。<br>如果有的函数非常重要，希望打印出’[INFO] call xxx()…’，有的函数不太重要，希望打印出’[DEBUG] call xxx()…’，这时，log函数本身就需要传入’INFO’或’DEBUG’这样的参数，类似这样：<br>    @log(‘DEBUG’)<br>    def my_func():<br>        pass<br>把上面的定义翻译成高阶函数的调用，就是：<br>    my_func = log(‘DEBUG’)(my_func)<br>上面的语句看上去还是比较绕，再展开一下：<br>    log_decorator = log(‘DEBUG’)<br>    my_func = log_decorator(my_func)<br>上面的语句又相当于：<br>    log_decorator = log(‘DEBUG’)<br>    @log_decorator<br>    def my_func():<br>        pass<br>所以，带参数的log函数首先返回一个decorator函数，再让这个decorator函数接收my_func并返回新函数：<br>    def log(prefix):<br>        def log_decorator(f):<br>            def wrapper(<em>args, **kw):<br>                print ‘[%s] %s()…’ % (prefix, f.<strong>name</strong>)<br>                return f(</em>args, **kw)<br>            return wrapper<br>        return log_decorator</p>
<pre><code>@log(&apos;DEBUG&apos;)
def test():
    pass
print test()
</code></pre><p><strong>执行结果：</strong><br>    [DEBUG] test()…<br>    None<br>对于这种3层嵌套的decorator定义，你可以先把它拆开：</p>
<pre><code># 标准decorator:def log_decorator(f):
    def wrapper(*args, **kw):
        print &apos;[%s] %s()...&apos; % (prefix, f.__name__)
        return f(*args, **kw)
    return wrapper
return log_decorator# 返回decorator:def log(prefix):
    return log_decorator(f)
</code></pre><p>拆开以后会发现，调用会失败，因为在3层嵌套的decorator定义中，最内层的wrapper引用了最外层的参数prefix，所以，把一个闭包拆成普通的函数调用会比较困难。不支持闭包的编程语言要实现同样的功能就需要更多的代码。</p>
<p>上一节的@performance只能打印秒，请给 @performace增加一个参数，允许传入’s’或’ms’：<br>    @performance(‘ms’)<br>    def factorial(n):<br>        return reduce(lambda x,y: x*y, range(1, n+1))</p>
<p>要实现带参数的@performance，就需要实现：<br>my_func = performance(‘ms’)(my_func)<br>需要3层嵌套的decorator来实现。<br><strong>参考代码:</strong><br>    import time<br>    def performance(unit):<br>        def perf_decorator(f):<br>            def wrapper(<em>args, **kw):<br>                t1 = time.time()<br>                r = f(</em>args, <em>*kw)<br>                t2 = time.time()<br>                t = (t2 - t1) </em> 1000 if unit==’ms’ else (t2 - t1)<br>                print ‘call %s() in %f %s’ % (f.<strong>name</strong>, t, unit)<br>                return r<br>            return wrapper<br>        return perf_decorator</p>
<pre><code>@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/Python编写带参数decorator/" data-id="cirdhs3dd000av4nrxngy0qzm" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Oracle基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/Oracle基础/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/Oracle基础/">Oracle基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、</p>
<p>2、用户<br>2、0、系统用户：sys，system，sysman，scott<br>2、1、登陆SQL Plus：<br>使用system登陆：[username/password] [@server]<br>请输入用户名：system/admin<br>SQL&gt;connect sys/admin as sysdba<br>2/2查看登陆用户<br>show user<br>desc dba_users<br>select username from dba_users;<br>2/3启用用户语句<br>alter user <code>username</code> account unlock;<br>connect <code>username</code>/<code>password</code></p>
<p>3、表空间<br>3/0表空间概述<br>永久表空间<br>临时表空间<br>UNDO表空间<br>3/1查看表空间<br>dba_tablespaces,dba_users;user_tablespaces,user_users;<br>select tablespace_name from dba_tablespaces;<br>3/2更改表空间<br>select default_tablespace,temporary_tablespace from dba_users where username=’SYSTEM’;<br>ALTER USER system DEFAULT TABLESPACE system;<br>3/3创建表空间<br>CREATE [TEMPORARY] TABLESPACE tablespace_name TEMPFILE | DATAFILE ‘xx.dbf’ SIZE xx;<br>例子：<br>create tablespace test1_tablespace datafile ‘test1file.dbf’ size 10m;<br>create temporary tablespace temptest1_tablespace tempfile ‘tempfile1.dbf’ size 10m;<br>desc dba_data_files;<br>select file_name from dba_data_files where tablespace_name=’TEST1_TABLESPACE’;<br>select file_name from dba_temp_files where tablespace_name=’TEMPTEST1_TABLESPACE’;<br>3/4修改表空间状态（默认ONLINE）<br>alter tablespace test1_tablespace offline;<br>desc dba_tablespaces;<br>select status from dba_tablespaces where tablespace_name=’TEST1_TABLESPACE’;<br>alter tablespace test1_tablespace read only;<br>alter tablespace test1_tablespace read write;<br>3/4修改数据文件<br>增加：ALTER TABLESPACE tablespace_name ADD DATAFILE ‘filename.dbf’ SIZE xx;<br>删除：ALTER TABLESPACE tablespace_name DROP DATAFILE ‘filename.dbf’;<br>例子：<br>alter tablespace test1_tablespace add datafile ‘test2_file.dbf’ size 10m;<br>select file_name from dba_data_files where tablespace_name=’TEST1_TABLESPACE’;<br>alter tablespace test1_tablespace drop datafile ‘test2_file.dbf’;<br>3/5删除表空间<br>DROP TABLESPACE tablespace_name [INCLUDING CONTENTS];</p>
<p>4、操作表<br>4/1数据类型<br>字符型：CHAR(n)–MAX2000 NCHAR(n)–MAX1000 VARCHAR2(n)–MAX4000 NVARCHAR2(n)–MAX2000<br>数值型：NUMBER(p,s)–p有效数字 FLOAT(n)<br>日期型：DATE–精确到秒 TIMESTAMP<br>其他类型：BLOB–4G–二进制 CLOB–4G–字符串<br>4/2管理表<br>新建表：<br>create table userinfo(<br> id number(6,0),<br> username varchar2(20),<br> userpwd varchar2(20),<br> email varchar2(30),<br> regdate date);<br>添加字段：<br>ALTER TABLE table_name ADD column_name datatype;<br>eg:<br>alter table userinfo<br>add remarks varchar2(500);<br>更改字段：<br>ALTER TABLE table_name MODIFY column_name datatype;<br>删除字段：<br>ALTER TABLE table_name DROP COLUMN column_name;<br>修改字段名：<br>ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;<br>修改表名：<br>RENAME table_name TO new_table_name;<br>清空表：<br>TRUNCATE TABLE table_name;<br>删除表：<br>DROP TABLE table_name;<br>4/3添加数据<br>INSERT INTO table_name(column1,column2,…) VALUES(value1,value2,…);</p>
<p>5、约束<br>非空约束、主键约束、外键约束<br>ADD CONSTRAINT constraint_name PRIMARY KEY(column1,….);<br>RENAME CONTRAINT old_name TO new_name;<br>DISABLE|ENABLE CONSTRAINT constraint_name;<br>DROP CONSTRAINT constraint_name;<br>DROP PRIMARY KEY[CASCADE];<br>5/5外键约束<br>CREATE TABLE table1(column_name datatype REFERENCES table2(cloumn_name),…);<br>要么是主表存在的值，要么是空值</p>
<p>CONSTRAINT constraint_name FOREIGN KEY(column_name) REFERENCES table_name(column_name) [ON DELETE CASCADE]</p>
<p>5/9唯一约束<br>CREATE TABLE table1(column_name datatype UNIQUE,…);<br>CONSTRAINT constraint_name UNIQUE(column_name);<br>约束名字唯一，多个约束多个语句</p>
<p>创建表后添加唯一约束：(ALTER TABLE table_name)<br>ADD CONSTRAINT un_constraint_name(column);</p>
<p>5/12检查约束<br>CREATE TABLE table_name(column_name datatype CHECK(expression),…);</p>
<p>添加检查约束：<br>CONSTRAINT ck_constraint_name CHECK(expression);</p>
<p>6、查询<br>带条件的查询<br>模糊查询<br>范围查询</p>
<p>设置格式<br>COLUMN|COL column_name HEADING new_name<br>COLUMN|COL column_name FORMAT dataformat<br>COLUMN|COL column_name CLEAR</p>
<p>6/6运算符和表达式</p>
<ul>
<li><ul>
<li><ul>
<li>/ &gt; &gt;= &lt; &lt;= = &lt;&gt; and or not<br>通配符’_ %’<br>范围查询<br>[NOT] BETWEEN … AND …<br>[NOT] IN<br>CASE column_name WHEN value THEN result,… [ELSE result] END<br>实例：select username ,case username when ‘xiaoming’ then ‘计算机’ when ‘daming’ then ‘不知道’ else ‘其他部门’ end as 部门 from userinfo;<br>CASE WHEN column_name=value THEN result … END<br>实例：select username ,case when username=’xiaoming’ then ‘计算机’ when id=3 then ‘unknown’ else ‘guizd’ end as wtf from userinfo;<br>DECODE函数<br>DECODE(column_name,value1,result1,…,defaultvalue)<br>实例：select  username ,decode(username,’xiaoming’,’计算机’,’daming’,’位置’,’其他’) as fuck from userinfo;</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/Oracle基础/" data-id="cirdhs3dd0009v4nrcwb6iiyr" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Oracle乱码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/Oracle乱码/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/Oracle乱码/">Oracle乱码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、连接windows 2003的oracle 11g<br>    C:>sqlplus / as sysdba<br>    SQL*Plus: Release 11.2.0.1.0 Production on 星期一 5月 21 15:03:29 2012<br>    Copyright (c) 1982, 2010, Oracle.  All rights reserved.<br>    连接到:<br>    Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production<br>    With the Partitioning, OLAP, Data Mining and Real Application Testing options  </p>
<p>2、查看客户端的字符集<br>    SQL&gt; select userenv(‘language’) from dual;  </p>
<pre><code>USERENV(&apos;LANGUAGE&apos;)  
----------------------------------------------------  
AMERICAN_AMERICA.ZHS16GBK  
</code></pre><p>3、查看服务端的字符集<br>    SQL&gt; set linesize 100<br>    SQL&gt; col parameter for a40<br>    SQL&gt; col value for a40<br>    SQL&gt; select * from nls_database_parameters where parameter like ‘%CHARACTERSET%%’;  </p>
<pre><code>PARAMETER                VALUE  
---------------------------------------- ----------------------------------------  
NLS_CHARACTERSET             ZHS16GBK  
NLS_NCHAR_CHARACTERSET       AL16UTF16  
</code></pre><p>可以看到客户端与服务端的字符集都是一致的，均为ZHS16GBK。<br>4、创建dl_char表<br>    SQL&gt; create table dl_char (name varchar2(20));  </p>
<pre><code>表已创建。  
</code></pre><p>5、插入数据<br>    SQL&gt; insert into dl_char values (‘字符集的乱码问题’);  </p>
<pre><code>已创建 1 行。  
</code></pre><p>6、进行select查询<br>    SQL&gt; select * from dl_char;  </p>
<pre><code>NAME  
--------------------  
字符集的乱码问题  
</code></pre><p>可以看得，现在显示为我刚才输入的值<br>7、更改客户端的字符集<br>    C:>SET NLS_LANG=AMERICAN_AMERICA.WE8ISO8859P1 </p>
<p>8、然后重新登录<br>    C:>sqlplus / as sysdba  </p>
<pre><code>SQL*Plus: Release 11.2.0.1.0 Production on Mon May 21 15:06:55 2012  

Copyright (c) 1982, 2010, Oracle.  All rights reserved.  


Connected to:  
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production  
With the Partitioning, OLAP, Data Mining and Real Application Testing options  
</code></pre><p>9、查看客户端的字符集<br>    SQL&gt; select userenv(‘language’) from dual;  </p>
<pre><code>USERENV(&apos;LANGUAGE&apos;)  
----------------------------------------------------  
AMERICAN_AMERICA.ZHS16GBK  
</code></pre><p>可以看到客户端的字符集已经变为AMERICAN_AMERICA.ZHS16GBK了<br>10、然后查看dl_char的值<br>    SQL&gt; select * from dl_char;  </p>
<pre><code>NAME  
--------------------  
靠靠靠靠  
</code></pre><p>现在就出现了我前面说的4个靠字的问题，从上面的实验，可以看到产生4靠的原因为：客户端与服务端的字符集不一致，所以解决这个问题的方法就是在客户端设置与服务端一致的字符集</p>
<p>11、现在把客户端的字符集改成与服务端一致的字符集<br>    C:>SET NLS_LANG=ZHS16GBK </p>
<p>12、然后登陆<br>    C:>sqlplus / as sysdba  </p>
<pre><code>SQL*Plus: Release 11.2.0.1.0 Production on 星期一 5月 21 15:13:11 2012  

Copyright (c) 1982, 2010, Oracle.  All rights reserved.  


连接到:  
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production  
With the Partitioning, OLAP, Data Mining and Real Application Testing options  
</code></pre><p>13、查看客户端与服务端的字符集<br>    SQL&gt; select userenv(‘language’) from dual;  </p>
<pre><code>USERENV(&apos;LANGUAGE&apos;)  
----------------------------------------------------  
SIMPLIFIED CHINESE_CHINA.ZHS16GBK  

SQL&gt; select * from nls_database_parameters where parameter like &apos;%CHARACTERSET%%&apos;;  

PARAMETER                VALUE  
---------------------------------------- ----------------------------------------  
NLS_CHARACTERSET             ZHS16GBK  
NLS_NCHAR_CHARACTERSET       AL16UTF16  
</code></pre><p>14、现在客户端与服务端的字符集都一致了，在查看一下dl_char里的内容<br>    SQL&gt; select * from dl_char;  </p>
<pre><code>NAME  
--------------------  
字符集的乱码问题  


     现在显示为正常的，4个靠字也没用在出现，所以以后在做exp/imp导出/导入或者客户端查询数据等操作的时候，一定要把客户端的字符集与服务端的字符集设置为同一个。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/Oracle乱码/" data-id="cirdhs3dd0008v4nrhuze8qxg" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ORACLE触发器详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/ORACLE触发器详解/" class="article-date">
  <time datetime="2016-08-02T13:18:52.146Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/ORACLE触发器详解/">ORACLE触发器详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>ORACLE PL/SQL编程之八：</strong><br><strong>把触发器说透</strong> </p>
<p><strong>本篇主要内容如下：</strong><br>8.1 触发器类型<br>8.1.1 DML触发器<br>8.1.2 替代触发器<br>8.1.3 系统触发器<br>8.2 创建触发器<br>8.2.1 触发器触发次序<br>8.2.2 创建DML触发器<br>8.2.3 创建替代(INSTEAD OF)触发器<br>8.2.3 创建系统事件触发器<br>8.2.4 系统触发器事件属性<br>8.2.5 使用触发器谓词<br>8.2.6 重新编译触发器<br>8.3 删除和使能触发器<br>8.4 触发器和数据字典<br>8.5   数据库触发器的应用举例</p>
<hr>
<p>触发器是许多关系数据库系统都提供的一项技术。在ORACLE系统里，触发器类似过程和函数，都有声明，执行和异常处理过程的PL/SQL块。<br><strong>8.1 触发器类型</strong><br>    触发器在数据库里以独立的对象存储，它与存储过程和函数不同的是，存储过程与函数需要用户显示调用才执行，而触发器是由一个事件来启动运行。即触发器是当某个事件发生时自动地隐式运行。并且，触发器不能接收参数。所以运行触发器就叫触发或点火（firing）。ORACLE事件指的是对数据库的表进行的INSERT、UPDATE及DELETE操作或对视图进行类似的操作。ORACLE将触发器的功能扩展到了触发ORACLE，如数据库的启动与关闭等。所以触发器常用来完成由数据库的完整性约束难以完成的复杂业务规则的约束，或用来监视对数据库的各种操作，实现审计的功能。</p>
<p><strong>8.1.1 DML触发器</strong><br>    ORACLE可以在DML语句进行触发，可以在DML操作前或操作后进行触发，并且可以对每个行或语句操作上进行触发。</p>
<p><strong>8.1.2 替代触发器</strong><br>    由于在ORACLE里，不能直接对由两个以上的表建立的视图进行操作。所以给出了替代触发器。它就是ORACLE 8专门为进行视图操作的一种处理方法。</p>
<p><strong>8.1.3 系统触发器</strong><br>ORACLE 8i 提供了第三种类型的触发器叫系统触发器。它可以在ORACLE数据库系统的事件中进行触发，如ORACLE系统的启动与关闭等。</p>
<p>触发器组成:<br>l         触发事件：引起触发器被触发的事件。 例如：DML语句(INSERT, UPDATE, DELETE语句对表或视图执行数据处理操作)、DDL语句（如CREATE、ALTER、DROP语句在数据库中创建、修改、删除模式对象）、数据库系统事件（如系统启动或退出、异常错误）、用户事件（如登录或退出数据库）。<br>l         触发时间：即该TRIGGER 是在触发事件发生之前（BEFORE）还是之后(AFTER)触发，也就是触发事件和该TRIGGER 的操作顺序。<br>l         触发操作：即该TRIGGER 被触发之后的目的和意图，正是触发器本身要做的事情。 例如：PL/SQL 块。<br>l         触发对象：包括表、视图、模式、数据库。只有在这些对象上发生了符合触发条件的触发事件，才会执行触发操作。<br>l         触发条件：由WHEN子句指定一个逻辑表达式。只有当该表达式的值为TRUE时，遇到触发事件才会自动执行触发器，使其执行触发操作。<br>l         触发频率：说明触发器内定义的动作被执行的次数。即语句级(STATEMENT)触发器和行级(ROW)触发器。<br>语句级(STATEMENT)触发器：是指当某触发事件发生时，该触发器只执行一次；<br>行级(ROW)触发器：是指当某触发事件发生时，对受到该操作影响的每一行数据，触发器都单独执行一次。<br><strong>编写触发器时，需要注意以下几点：</strong><br>l         触发器不接受参数。<br>l         一个表上最多可有12个触发器，但同一时间、同一事件、同一类型的触发器只能有一个。并各触发器之间不能有矛盾。<br>l         在一个表上的触发器越多，对在该表上的DML操作的性能影响就越大。<br>l        触发器最大为32KB。若确实需要，可以先建立过程，然后在触发器中用CALL语句进行调用。<br>l         <strong>在触发器的执行部分只能用DML语句（SELECT、INSERT、UPDATE、DELETE），不能使用DDL语句（CREATE、ALTER、DROP）</strong>。<br>l         触发器中不能包含事务控制语句(COMMIT，ROLLBACK，SAVEPOINT)。因为触发器是触发语句的一部分，触发语句被提交、回退时，触发器也被提交、回退了。<br>l         在触发器主体中调用的任何过程、函数，都不能使用事务控制语句。<br>l         在触发器主体中不能申明任何Long和blob变量。新值new和旧值old也不能是表中的任何long和blob列。<br>l         不同类型的触发器(如DML触发器、INSTEAD OF触发器、系统触发器)的语法格式和作用有较大区别。<strong>
</strong><br><strong>8.2 创建触发器</strong><br><strong>创建触发器的一般语法是:</strong></p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE [OR REPLACE] TRIGGER trigger_name<br>{BEFORE | AFTER }<br>{INSERT | DELETE | UPDATE [OF column [, column …]]}<br>[OR {INSERT | DELETE | UPDATE [OF column [, column …]]}…]<br>ON [schema.]table_name | [schema.]view_name<br>[REFERENCING {OLD [AS] old | NEW [AS] new| PARENT as parent}]<br>[FOR EACH ROW ]<br>[WHEN condition]<br>PL/SQL_BLOCK | CALL procedure_name;<br><a href="&quot;复制代码&quot;"></a></p>
<p>其中：<br>BEFORE 和AFTER指出触发器的触发时序分别为前触发和后触发方式，前触发是在执行触发事件之前触发当前所创建的触发器，后触发是在执行触发事件之后触发当前所创建的触发器。<br>       FOR EACH ROW选项说明触发器为行触发器。行触发器和语句触发器的区别表现在：行触发器要求当一个DML语句操作影响数据库中的多行数据时，对于其中的每个数据行，只要它们符合触发约束条件，均激活一次触发器；而语句触发器将整个语句操作作为触发事件，当它符合约束条件时，激活一次触发器。当省略FOR EACH ROW 选项时，BEFORE 和AFTER 触发器为语句触发器，而INSTEAD<br> OF 触发器则只能为行触发器。<br>           REFERENCING 子句说明相关名称，在行触发器的PL/SQL块和WHEN 子句中可以使用相关名称参照当前的新、旧列值，默认的相关名称分别为OLD和NEW。触发器的PL/SQL块中应用相关名称时，必须在它们之前加冒号(:)，但在WHEN子句中则不能加冒号。<br>WHEN 子句说明触发约束条件。Condition 为一个逻辑表达时，其中必须包含相关名称，而不能包含查询语句，也不能调用PL/SQL 函数。WHEN 子句指定的触发约束条件只能用在BEFORE 和AFTER 行触发器中，不能用在INSTEAD OF 行触发器和其它类型的触发器中。<br>    当一个基表被修改( INSERT, UPDATE, DELETE)时要执行的存储过程，执行时根据其所依附的基表改动而自动触发，因此与应用程序无关，用数据库触发器可以保证数据的一致性和完整性。</p>
<hr>
<p>每张表最多可建立12 种类型的触发器，它们是:<br>BEFORE INSERT<br>BEFORE INSERT FOR EACH ROW<br>AFTER INSERT<br>AFTER INSERT FOR EACH ROW</p>
<p>BEFORE UPDATE<br>BEFORE UPDATE FOR EACH ROW<br>AFTER UPDATE<br>AFTER UPDATE FOR EACH ROW</p>
<p>BEFORE DELETE<br>BEFORE DELETE FOR EACH ROW<br>AFTER DELETE<br>AFTER DELETE FOR EACH ROW</p>
<p><strong>8.2.1 触发器触发次序</strong></p>
<ol>
<li>执行 BEFORE语句级触发器;</li>
<li>对与受语句影响的每一行：<br>l         执行 BEFORE行级触发器<br>l         执行 DML语句<br>l         执行 AFTER行级触发器 </li>
<li>执行 AFTER语句级触发器</li>
</ol>
<p><strong>8.2.2 创建DML触发器</strong><br>    触发器名与过程名和包的名字不一样，它是单独的名字空间，因而触发器名可以和表或过程有相同的名字，但在一个模式中触发器名不能相同。</p>
<hr>
<p><strong>DML触发器的限制</strong><br>l         CREATE TRIGGER语句文本的字符长度不能超过32KB；<br>l         触发器体内的SELECT 语句只能为SELECT … INTO …结构，或者为定义游标所使用的SELECT 语句。<br>l         触发器中不能使用数据库事务控制语句 COMMIT; ROLLBACK, SVAEPOINT 语句；<br>l         由触发器所调用的过程或函数也不能使用数据库事务控制语句；<br>l         触发器中不能使用LONG, LONG RAW 类型；<br>l         触发器内可以参照LOB 类型列的列值，但不能通过 :NEW 修改LOB列中的数据；</p>
<hr>
<p><strong>DML触发器基本要点</strong><br>l         <strong>触发时机：</strong>指定触发器的触发时间。如果指定为BEFORE，则表示在执行DML操作之前触发，以便防止某些错误操作发生或实现某些业务规则；如果指定为AFTER，则表示在执行DML操作之后触发，以便记录该操作或做某些事后处理。<br>l         <strong>触发事件：</strong>引起触发器被触发的事件，即DML操作（INSERT、UPDATE、DELETE）。既可以是单个触发事件，也可以是多个触发事件的组合（只能使用OR逻辑组合，不能使用AND逻辑组合）。<br>l         <strong>条件谓词：</strong>当在触发器中包含多个触发事件（INSERT、UPDATE、DELETE）的组合时，为了分别针对不同的事件进行不同的处理，需要使用ORACLE提供的如下条件谓词。<br>1）。<strong>INSERTING：</strong>当触发事件是INSERT时，取值为TRUE，否则为FALSE。<br>2）。<strong>UPDATING [（column_1,column_2,…,column_x）]：</strong>当触发事件是UPDATE      时，如果修改了column_x列，则取值为TRUE，否则为FALSE。其中column_x是可选的。<br>3）。<strong>DELETING：</strong>当触发事件是DELETE时，则取值为TRUE，否则为FALSE。<br><strong>解发对象：</strong>指定触发器是创建在哪个表、视图上。<br>l         <strong>触发类型：</strong>是语句级还是行级触发器。<br>l         <strong>触发条件：</strong>由WHEN子句指定一个逻辑表达式，只允许在行级触发器上指定触发条件，指定UPDATING后面的列的列表。</p>
<hr>
<p>问题：当触发器被触发时，要使用被插入、更新或删除的记录中的列值，有时要使用操作前、        后列的值.<br>实现:  :NEW 修饰符访问操作完成后列的值<br>       :OLD 修饰符访问操作完成前列的值</p>
<p>特性<br>INSERT<br>UPDATE<br>DELETE<br>OLD<br>NULL<br>实际值<br>实际值<br>NEW<br>实际值<br>实际值<br>NULL</p>
<p><strong>例1:</strong> 建立一个触发器, 当职工表 emp 表被删除一条记录时，把被删除记录写到职工表删除日志表中去。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE TABLE emp_his AS SELECT <em> FROM EMP WHERE <strong>1</strong>=<strong>2</strong>;<br>CREATE OR REPLACE TRIGGER tr_del_emp<br>   BEFORE DELETE –指定触发时机为删除操作前触发<br>   ON scott.emp<br>   FOR EACH ROW   –说明创建的是行级触发器<br>BEGIN<br>   –将修改前数据插入到日志记录表 del_emp ,以供监督使用。<br>   INSERT INTO emp_his(deptno , empno, ename , job ,mgr , sal , comm , hiredate )<br>       VALUES( :old.deptno, :old.empno, :old.ename , :old.job,:old.mgr, :old.sal, :old.comm, :old.hiredate );<br>END;<br>DELETE emp WHERE empno=<em>*7788</em></em>;<br>DROP TABLE emp_his;<br>DROP TRIGGER del_emp;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例2：</strong>限制对Departments表修改（包括INSERT,DELETE,UPDATE）的时间范围，即不允许在非工作时间修改departments表。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE OR REPLACE TRIGGER tr_dept_time<br>BEFORE INSERT OR DELETE OR UPDATE<br>ON departments<br>BEGIN<br> IF (TO_CHAR(sysdate,’DAY’) IN (‘星期六’, ‘星期日’)) OR (TO_CHAR(sysdate, ‘HH24:MI’) NOT BETWEEN ‘08:30’ AND ‘18:00’) THEN<br>     RAISE_APPLICATION_ERROR(-<strong>20001</strong>, ‘不是上班时间，不能修改departments表’);<br> END IF;<br>END;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例3：</strong>限定只对部门号为80的记录进行行触发器操作。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE OR REPLACE TRIGGER tr_emp_sal_comm<br>BEFORE UPDATE OF salary, commission_pct<br>       OR DELETE<br>ON HR.employees<br>FOR EACH ROW<br>WHEN (old.department_id = <strong>80</strong>)<br>BEGIN<br> CASE<br>     WHEN UPDATING (‘salary’) THEN<br>        IF :NEW.salary &lt; :old.salary THEN</p>
<pre><code>      RAISE_APPLICATION_ERROR(-**20001**, &apos;部门80的人员的工资不能降&apos;);
   END IF;
WHEN UPDATING (&apos;commission_pct&apos;) THEN

   IF :NEW.commission_pct &lt; :old.commission_pct THEN
      RAISE_APPLICATION_ERROR(-**20002**, &apos;部门80的人员的奖金不能降&apos;);
   END IF;
WHEN DELETING THEN
     RAISE_APPLICATION_ERROR(-**20003**, &apos;不能删除部门80的人员记录&apos;);
END CASE;
</code></pre><p>END; </p>
<p>/<em><br>实例：<br>UPDATE employees SET salary = 8000 WHERE employee_id = 177;<br>DELETE FROM employees WHERE employee_id in (177,170);
</em>/<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例4：</strong>利用行触发器实现级联更新。在修改了主表regions中的region_id之后（AFTER），级联的、自动的更新子表countries表中原来在该地区的国家的region_id。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE OR REPLACE TRIGGER tr_reg_cou<br>AFTER update OF region_id<br>ON regions<br>FOR EACH ROW<br>BEGIN<br> DBMS_OUTPUT.PUT_LINE(‘旧的region_id值是’||:old.region_id<br>                  ||’、新的region_id值是’||:new.region_id);<br> UPDATE countries SET region_id = :new.region_id<br> WHERE region_id = :old.region_id;<br>END;<br><a href="&quot;复制代码&quot;"></a><br><strong>例5：</strong>在触发器中调用过程。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE OR REPLACE PROCEDURE add_job_history<br> ( p_emp_id          job_history.employee_id%type<br>   , p_start_date      job_history.start_date%type<br>  , p_end_date        job_history.end_date%type<br>   , p_job_id          job_history.job_id%type<br>   , p_department_id   job_history.department_id%type<br>   )<br>IS<br>BEGIN<br> INSERT INTO job_history (employee_id, start_date, end_date,<br>                           job_id, department_id)<br>  VALUES(p_emp_id, p_start_date, p_end_date, p_job_id, p_department_id);<br>END add_job_history;</p>
<p>–创建触发器调用存储过程…<br>CREATE OR REPLACE TRIGGER update_job_history<br> AFTER UPDATE OF job_id, department_id ON employees<br> FOR EACH ROW<br>BEGIN<br> add_job_history(:old.employee_id, :old.hire_date, sysdate,<br>                  :old.job_id, :old.department_id);<br>END;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>8.2.3 创建替代(INSTEAD OF)触发器</strong></p>
<p><strong>创建触发器的一般语法是:</strong></p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE [OR REPLACE] TRIGGER trigger_name<br>INSTEAD OF<br>{INSERT | DELETE | UPDATE [OF column [, column …]]}<br>[OR {INSERT | DELETE | UPDATE [OF column [, column …]]}…]<br>ON [schema.] view_name –只能定义在视图上<br>[REFERENCING {OLD [AS] old | NEW [AS] new| PARENT as parent}]<br>[FOR EACH ROW ] –因为INSTEAD OF触发器只能在行级上触发,所以没有必要指定<br>[WHEN condition]<br>PL/SQL_block | CALL procedure_name;<br><a href="&quot;复制代码&quot;"></a></p>
<p>其中：<br>           INSTEAD OF 选项使ORACLE激活触发器，而不执行触发事件。只能对视图和对象视图建立INSTEAD OF触发器，而不能对表、模式和数据库建立INSTEAD OF 触发器。<br>           FOR EACH ROW选项说明触发器为行触发器。行触发器和语句触发器的区别表现在：行触发器要求当一个DML语句操走影响数据库中的多行数据时，对于其中的每个数据行，只要它们符合触发约束条件，均激活一次触发器；而语句触发器将整个语句操作作为触发事件，当它符合约束条件时，激活一次触发器。当省略FOR EACH ROW 选项时，BEFORE 和AFTER 触发器为语句触发器，而INSTEAD OF 触发器则为行触发器。<br>           REFERENCING 子句说明相关名称，在行触发器的PL/SQL块和WHEN 子句中可以使用相关名称参照当前的新、旧列值，默认的相关名称分别为OLD和NEW。触发器的PL/SQL块中应用相关名称时，必须在它们之前加冒号(:)，但在WHEN子句中则不能加冒号。<br>WHEN 子句说明触发约束条件。Condition 为一个逻辑表达时，其中必须包含相关名称，而不能包含查询语句，也不能调用PL/SQL 函数。WHEN 子句指定的触发约束条件只能用在BEFORE 和AFTER 行触发器中，不能用在INSTEAD OF 行触发器和其它类型的触发器中。</p>
<pre><code>INSTEAD_OF 用于对视图的DML触发，由于视图有可能是由多个表进行联结(join)而成，因而并非是所有的联结都是可更新的。但可以按照所需的方式执行更新，例如下面情况：
</code></pre><p><strong>例1：</strong></p>
<p>CREATE OR REPLACE VIEW emp_view AS<br>SELECT deptno, count(*) total_employeer, sum(sal) total_salary<br>FROM emp GROUP BY deptno;</p>
<p>在此视图中直接删除是非法：<br>SQL&gt;DELETE FROM emp_view WHERE deptno=<strong>10</strong>;<br>DELETE FROM emp_view WHERE deptno=<strong>10</strong></p>
<p>ERROR 位于第 1 行:<br>ORA-01732: 此视图的数据操纵操作非法</p>
<p>但是我们可以创建INSTEAD_OF触发器来为 DELETE 操作执行所需的处理，即删除EMP表中所有基准行：</p>
<hr>
<p><strong><a href="&quot;复制代码&quot;"></a></strong><br>**CREATE OR REPLACE TRIGGER emp_view_delete<br>   INSTEAD OF DELETE ON emp_view FOR EACH ROW<br>BEGIN<br>   DELETE FROM emp WHERE deptno= :old.deptno;<br>END emp_view_delete; </p>
<p>DELETE FROM emp_view WHERE deptno=10; </p>
<p>DROP TRIGGER emp_view_delete;</p>
<p>DROP VIEW emp_view; <strong>
</strong><a href="&quot;复制代码&quot;"></a>**</p>
<p><strong>例2：</strong>创建复杂视图，针对INSERT操作创建INSTEAD OF触发器，向复杂视图插入数据。<br>l         创建视图：</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE OR REPLACE FORCE VIEW “HR”.”V_REG_COU” (“R_ID”, “R_NAME”, “C_ID”, “C_NAME”)<br>AS<br> SELECT r.region_id,<br>    r.region_name,<br>    c.country_id,<br>    c.country_name<br> FROM regions r,<br>    countries c<br> WHERE r.region_id = c.region_id;<br><a href="&quot;复制代码&quot;"></a></p>
<p>l        创建触发器：</p>
<hr>
<p><strong><a href="&quot;复制代码&quot;"></a></strong><br><em>*CREATE OR REPLACE TRIGGER “HR”.”TR_I_O_REG_COU” INSTEAD OF<br> INSERT ON v_reg_cou FOR EACH ROW DECLARE v_count NUMBER;<br>BEGIN<br> SELECT COUNT(</em>) INTO v_count FROM regions WHERE region_id = :new.r_id;<br> IF v_count = 0 THEN<br>    INSERT INTO regions<br>      (region_id, region_name<br>      ) VALUES<br>      (:new.r_id, :new.r_name<br>      );<br> END IF;</p>
<p> SELECT COUNT(<em>) INTO v_count FROM countries WHERE country_id = :new.c_id;<br> IF v_count = 0 THEN<br>    INSERT<br>    INTO countries<br>      (<br>        country_id,<br>        country_name,<br>        region_id<br>      )<br>      VALUES<br>      (<br>        :new.c_id,<br>        :new.c_name,<br>        :new.r_id<br>      );<br> END IF;<br>END;<strong>
</strong><a href="&quot;复制代码&quot;"></a>*</em></p>
<hr>
<p><strong>创建INSTEAD OF触发器需要注意以下几点：</strong><br>l         只能被创建在视图上，并且该视图没有指定WITH CHECK OPTION选项。<br>l         不能指定BEFORE 或 AFTER选项。<br>l         FOR EACH ROW子可是可选的，即INSTEAD OF触发器只能在行级上触发、或只能是行级触发器，没有必要指定。<br>l         没有必要在针对一个表的视图上创建INSTEAD OF触发器，只要创建DML触发器就可以了。</p>
<hr>
<p><strong>8.2.3 创建系统事件触发器</strong><br>    ORACLE10G提供的系统事件触发器可以在DDL或数据库系统上被触发。DDL指的是数据定义语言，如CREATE 、ALTER及DROP 等。而数据库系统事件包括数据库服务器的启动或关闭，用户的登录与退出、数据库服务错误等。创建系统触发器的语法如下：<br><strong>创建触发器的一般语法是:</strong></p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE OR REPLACE TRIGGER [sachema.]trigger_name<br>{BEFORE|AFTER}<br>{ddl_event_list | database_event_list}<br>ON { DATABASE | [schema.]SCHEMA }<br>[WHEN condition]<br>PL/SQL_block | CALL procedure_name;<br><a href="&quot;复制代码&quot;"></a></p>
<p>其中: ddl_event_list：一个或多个DDL 事件，事件间用 OR 分开；<br>        database_event_list：一个或多个数据库事件，事件间用 OR 分开；</p>
<pre><code>系统事件触发器既可以建立在一个模式上，又可以建立在整个数据库上。当建立在模式(SCHEMA)之上时，只有模式所指定用户的DDL操作和它们所导致的错误才激活触发器, 默认时为当前用户模式。当建立在数据库(DATABASE)之上时，该数据库所有用户的DDL操作和他们所导致的错误，以及数据库的启动和关闭均可激活触发器。要在数据库之上建立触发器时，要求用户具有ADMINISTER DATABASE TRIGGER权限。
</code></pre><p>下面给出系统触发器的种类和事件出现的时机（前或后）：<br><strong>事件</strong><br><strong>允许的时机</strong><br><strong>说明</strong><br>STARTUP<br>AFTER<br>启动数据库实例之后触发<br>SHUTDOWN<br>BEFORE<br>关闭数据库实例之前触发（非正常关闭不触发）<br>SERVERERROR<br>AFTER<br>数据库服务器发生错误之后触发<br>LOGON<br>AFTER<br>成功登录连接到数据库后触发<br>LOGOFF<br>BEFORE<br>开始断开数据库连接之前触发<br>CREATE<br>BEFORE，AFTER<br>在执行CREATE语句创建数据库对象之前、之后触发<br>DROP<br>BEFORE，AFTER<br>在执行DROP语句删除数据库对象之前、之后触发<br>ALTER<br>BEFORE，AFTER<br>在执行ALTER语句更新数据库对象之前、之后触发<br>DDL<br>BEFORE，AFTER<br>在执行大多数DDL语句之前、之后触发<br>GRANT<br>BEFORE，AFTER<br>执行GRANT语句授予权限之前、之后触发<br>REVOKE<br>BEFORE，AFTER<br>执行REVOKE语句收权限之前、之后触犯发<br>RENAME<br>BEFORE，AFTER<br>执行RENAME语句更改数据库对象名称之前、之后触犯发<br>AUDIT <strong>/ </strong>NOAUDIT<br>BEFORE，AFTER<br>执行AUDIT<strong>或</strong>NOAUDIT进行审计或停止审计之前、之后触发</p>
<p><strong>8.2.4 系统触发器事件属性</strong></p>
<p>事件属性\事件<br>Startup/Shutdown<br>Servererror<br>Logon/Logoff<br>DDL<br>DML<br>事件名称<br><strong>ü＊</strong><br><strong>ü＊</strong><br><strong>ü＊</strong><br><strong>ü＊</strong><br><strong>＊</strong><br>数据库名称<br><strong>ü＊</strong></p>
<hr>
<hr>
<hr>
<hr>
<p>数据库实例号<br><strong>ü＊</strong></p>
<hr>
<hr>
<hr>
<hr>
<p>错误号</p>
<hr>
<p><strong>ü＊</strong></p>
<hr>
<hr>
<hr>
<p>用户名</p>
<hr>
<hr>
<p><strong>ü＊</strong><br><strong>＊</strong></p>
<hr>
<p>模式对象类型</p>
<hr>
<hr>
<hr>
<p><strong>ü＊</strong><br><strong>＊</strong><br>模式对象名称</p>
<hr>
<hr>
<hr>
<p><strong>ü＊</strong><br><strong>＊</strong><br>列</p>
<hr>
<hr>
<hr>
<hr>
<p><strong>ü＊</strong></p>
<p>除DML语句的列属性外，其余事件属性值可通过调用ORACLE定义的事件属性函数来读取。<br>函数名称<br>数据类型<br>说    明<br>Ora_sysevent<br>VARCHAR2（20）<br>激活触发器的事件名称<br>Instance_num<br>NUMBER<br>数据库实例名<br>Ora_database_name<br>VARCHAR2（50）<br>数据库名称<br>Server_error(posi)<br>NUMBER<br>错误信息栈中posi指定位置中的错误号</p>
<p>Is_servererror(err_number)</p>
<p>BOOLEAN<br>检查err_number指定的错误号是否在错误信息栈中，如果在则返回TRUE，否则返回FALSE。在触发器内调用此函数可以判断是否发生指定的错误。<br>Login_user<br>VARCHAR2(30)<br>登陆或注销的用户名称<br>Dictionary_obj_type<br>VARCHAR2(20)<br>DDL语句所操作的数据库对象类型<br>Dictionary_obj_name<br>VARCHAR2(30)<br>DDL语句所操作的数据库对象名称<br>Dictionary_obj_owner<br>VARCHAR2(30)<br>DDL语句所操作的数据库对象所有者名称<br>Des_encrypted_password<br>VARCHAR2(2)<br>正在创建或修改的经过DES算法加密的用户口令</p>
<hr>
<p><strong>例1：</strong>创建触发器，存放有关事件信息。<br><a href="&quot;复制代码&quot;"></a><br>DESC ora_sysevent<br>DESC ora_login_user</p>
<p>–创建用于记录事件用的表</p>
<p>CREATE TABLE ddl_event<br>(crt_date timestamp PRIMARY KEY,<br> event_name VARCHAR2(<strong>20</strong>),<br> user_name VARCHAR2(<strong>10</strong>),<br> obj_type VARCHAR2(<strong>20</strong>),<br> obj_name VARCHAR2(<strong>20</strong>));</p>
<p>–创建触犯发器<br>CREATE OR REPLACE TRIGGER tr_ddl<br>AFTER DDL ON SCHEMA<br>BEGIN<br>   INSERT INTO ddl_event VALUES<br>   (systimestamp,ora_sysevent, ora_login_user,<br>    ora_dict_obj_type, ora_dict_obj_name);<br>END tr_ddl;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例2：</strong>创建登录、退出触发器。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE TABLE log_event<br>(user_name VARCHAR2(<strong>10</strong>),<br> address VARCHAR2(<strong>20</strong>),<br> logon_date timestamp,<br> logoff_date timestamp); </p>
<p>–创建登录触发器<br>CREATE OR REPLACE TRIGGER tr_logon<br>AFTER LOGON ON DATABASE<br>BEGIN<br>   INSERT INTO log_event (user_name, address, logon_date)<br>   VALUES (ora_login_user, ora_client_ip_address, systimestamp);<br>END tr_logon;<br>–创建退出触发器<br>CREATE OR REPLACE TRIGGER tr_logoff<br>BEFORE LOGOFF ON DATABASE<br>BEGIN<br>   INSERT INTO log_event (user_name, address, logoff_date)<br>   VALUES (ora_login_user, ora_client_ip_address, systimestamp);<br>END tr_logoff;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>8.2.5 使用触发器谓词</strong><br>    ORACLE 提供三个参数INSERTING, UPDATING,DELETING 用于判断触发了哪些操作。<br>谓词<br>行为<br>INSERTING<br>如果触发语句是 INSERT 语句，则为TRUE,否则为FALSE<br>UPDATING<br>如果触发语句是 UPDATE语句，则为TRUE,否则为FALSE<br>DELETING<br>如果触发语句是 DELETE 语句，则为TRUE,否则为FALSE</p>
<hr>
<p><strong>8.2.6 重新编译触发器</strong><br>如果在触发器内调用其它函数或过程，当这些函数或过程被删除或修改后，触发器的状态将被标识为无效。当DML语句激活一个无效触发器时，ORACLE将重新编译触发器代码，如果编译时发现错误，这将导致DML语句执行失败。<br>在PL/SQL程序中可以调用ALTER TRIGGER语句重新编译已经创建的触发器，格式为：<br>ALTER TRIGGER [schema.] trigger_name COMPILE [ DEBUG]<br>       其中：DEBUG 选项要器编译器生成PL/SQL 程序条使其所使用的调试代码。<br><strong>8.3 删除和使能触发器</strong><br>l         <strong>删除触发器：</strong><br>DROP TRIGGER trigger_name;<br>当删除其他用户模式中的触发器名称，需要具有DROP ANY TRIGGER系统权限，当删除建立在数据库上的触发器时，用户需要具有ADMINISTER DATABASE TRIGGER系统权限。<br>此外，当删除表或视图时，建立在这些对象上的触发器也随之删除。<br>l         <strong>禁用或启用触发器</strong><br>数据库TRIGGER 的状态：<br>有效状态(ENABLE)：当触发事件发生时，处于有效状态的数据库触发器TRIGGER 将被触发。<br>无效状态(DISABLE)：当触发事件发生时，处于无效状态的数据库触发器TRIGGER 将不会被触发，此时就跟没有这个数据库触发器(TRIGGER) 一样。<br>数据库TRIGGER的这两种状态可以互相转换。格式为：<br>ALTER TIGGER trigger_name [DISABLE | ENABLE ];</p>
<p>–例：ALTER TRIGGER emp_view_delete DISABLE;</p>
<pre><code>ALTER TRIGGER语句一次只能改变一个触发器的状态，而ALTER TABLE语句则一次能够改变与指定表相关的所有触发器的使用状态。格式为：             
</code></pre><p>ALTER TABLE [schema.]table_name {ENABLE|DISABLE} ALL TRIGGERS;</p>
<p>–例：使表EMP 上的所有TRIGGER 失效：<br>ALTER TABLE emp DISABLE ALL TRIGGERS; </p>
<p><strong>8.4 触发器和数据字典</strong><br>相关数据字典：USER_TRIGGERS、ALL_TRIGGERS、DBA_TRIGGERS<br>SELECT TRIGGER_NAME, TRIGGER_TYPE, TRIGGERING_EVENT,<br> TABLE_OWNER, BASE_OBJECT_TYPE, REFERENCING_NAMES,<br> STATUS, ACTION_TYPE<br> FROM user_triggers;</p>
<p><strong>8.5   数据库触发器的应用举例</strong><br><strong>例1：</strong>创建一个DML语句级触发器，当对emp表执行INSERT, UPDATE, DELETE 操作时，它自动更新dept_summary 表中的数据。由于在PL/SQL块中不能直接调用DDL语句，所以，利用ORACLE内置包DBMS_UTILITY中的EXEC_DDL_STATEMENT过程，由它执行DDL语句创建触发器。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE TABLE dept_summary(<br> Deptno NUMBER(<strong>2</strong>),<br> Sal_sum NUMBER(<strong>9</strong>, <strong>2</strong>),<br> Emp_count NUMBER); </p>
<p>INSERT INTO dept_summary(deptno, sal_sum, emp_count)<br> SELECT deptno, SUM(sal), COUNT(*)<br>FROM emp<br>GROUP BY deptno;</p>
<p>–创建一个PL/SQL过程disp_dept_summary<br>–在触发器中调用该过程显示dept_summary标中的数据。<br>CREATE OR REPLACE PROCEDURE disp_dept_summary<br>IS<br> Rec dept_summary%ROWTYPE;<br> CURSOR c1 IS SELECT <em> FROM dept_summary;<br>BEGIN<br> OPEN c1;<br> FETCH c1 INTO REC;<br> DBMS_OUTPUT.PUT_LINE(‘deptno    sal_sum    emp_count’);<br> DBMS_OUTPUT.PUT_LINE(‘————————————-‘);<br> WHILE c1%FOUND LOOP<br>    DBMS_OUTPUT.PUT_LINE(RPAD(rec.deptno, <strong>6</strong>)||<br>      To_char(rec.sal_sum, ‘$999,999.99’)||<br>      LPAD(rec.emp_count, <strong>13</strong>));<br>    FETCH c1 INTO rec;<br> END LOOP;<br> CLOSE c1;<br>END;<br>BEGIN<br> DBMS_OUTPUT.PUT_LINE(‘插入前’);<br> Disp_dept_summary();<br> DBMS_UTILITY.EXEC_DDL_STATEMENT(‘<br>    CREATE OR REPLACE TRIGGER trig1<br>      AFTER INSERT OR DELETE OR UPDATE OF sal ON emp<br>    BEGIN<br>      DBMS_OUTPUT.PUT_LINE(‘’正在执行trig1 触发器…’’);<br>      DELETE FROM dept_summary;<br>      INSERT INTO dept_summary(deptno, sal_sum, emp_count)<br>      SELECT deptno, SUM(sal), COUNT(</em>)<br>      FROM emp GROUP BY deptno;<br>    END;<br> ‘);</p>
<p> INSERT INTO dept(deptno, dname, loc)<br> VALUES(<strong>90</strong>, ‘demo_dept’, ‘none_loc’);<br> INSERT INTO emp(ename, deptno, empno, sal)<br> VALUES(USER, <strong>90</strong>, <strong>9999</strong>, <strong>3000</strong>);</p>
<p> DBMS_OUTPUT.PUT_LINE(‘插入后’);<br> Disp_dept_summary();</p>
<p> UPDATE emp SET sal=<strong>1000</strong> WHERE empno=<strong>9999</strong>;<br> DBMS_OUTPUT.PUT_LINE(‘修改后’);<br> Disp_dept_summary();</p>
<p> DELETE FROM emp WHERE empno=<strong>9999</strong>;<br> DELETE FROM dept WHERE deptno=<strong>90</strong>;</p>
<p> DBMS_OUTPUT.PUT_LINE(‘删除后’);<br> Disp_dept_summary();<br> DBMS_UTILITY.EXEC_DDL_STATEMENT(‘DROP TRIGGER trig1’);<br>EXCEPTION<br>   WHEN OTHERS THEN<br>      DBMS_OUTPUT.PUT_LINE(SQLCODE||’—‘||SQLERRM);</p>
<p>END;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例2：</strong>创建DML语句行级触发器。当对emp表执行INSERT, UPDATE, DELETE 操作时，它自动更新dept_summary 表中的数据。由于在PL/SQL块中不能直接调用DDL语句，所以，利用ORACLE内置包DBMS_UTILITY中的EXEC_DDL_STATEMENT过程，由它执行DDL语句创建触发器。</p>
<p><a href="&quot;复制代码&quot;"></a><br>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(‘插入前’);<br>  Disp_dept_summary();<br>  DBMS_UTILITY.EXEC_DDL_STATEMENT(<br>    ‘CREATE OR REPLACE TRIGGER trig2_update<br>      AFTER UPDATE OF sal ON emp<br>      REFERENCING OLD AS old_emp NEW AS new_emp<br>      FOR EACH ROW<br>      WHEN (old_emp.sal != new_emp.sal)<br>    BEGIN<br>      DBMS_OUTPUT.PUT_LINE(‘’正在执行trig2_update 触发器…’’);<br>      DBMS_OUTPUT.PUT_LINE(‘’sal 旧值：’’|| :old_emp.sal);<br>      DBMS_OUTPUT.PUT_LINE(‘’sal 新值：’’|| :new_emp.sal);<br>      UPDATE dept_summary<br>        SET sal_sum=sal_sum + :new_emp.sal - :old_emp.sal<br>        WHERE deptno = :new_emp.deptno;<br>    END;’<br>  );</p>
<p>  DBMS_UTILITY.EXEC_DDL_STATEMENT(<br>    ‘CREATE OR REPLACE TRIGGER trig2_insert<br>      AFTER INSERT ON emp<br>      REFERENCING NEW AS new_emp<br>      FOR EACH ROW<br>    DECLARE<br>      I NUMBER;<br>    BEGIN<br>      DBMS_OUTPUT.PUT_LINE(‘’正在执行trig2_insert 触发器…’’);<br>      SELECT COUNT(*) INTO I<br>      FROM dept_summary WHERE deptno = :new_emp.deptno;<br>      IF I &gt; 0 THEN<br>        UPDATE dept_summary<br>        SET sal_sum=sal_sum+:new_emp.sal,<br>        Emp_count=emp_count+1<br>        WHERE deptno = :new_emp.deptno;<br>      ELSE<br>        INSERT INTO dept_summary<br>        VALUES (:new_emp.deptno, :new_emp.sal, 1);<br>      END IF;<br>    END;’<br>  );</p>
<p>  DBMS_UTILITY.EXEC_DDL_STATEMENT(<br>    ‘CREATE OR REPLACE TRIGGER trig2_delete<br>      AFTER DELETE ON emp<br>      REFERENCING OLD AS old_emp<br>      FOR EACH ROW<br>    DECLARE<br>      I NUMBER;<br>    BEGIN<br>      DBMS_OUTPUT.PUT_LINE(‘’正在执行trig2_delete 触发器…’’);<br>      SELECT emp_count INTO I<br>      FROM dept_summary WHERE deptno = :old_emp.deptno;<br>      IF I &gt;1 THEN<br>        UPDATE dept_summary<br>        SET sal_sum=sal_sum - :old_emp.sal,<br>        Emp_count=emp_count - 1<br>        WHERE deptno = :old_emp.deptno;<br>      ELSE<br>        DELETE FROM dept_summary WHERE deptno = :old_emp.deptno;<br>      END IF;<br>    END;’<br>  );</p>
<p>  INSERT INTO dept(deptno, dname, loc)<br>    VALUES(<strong>90</strong>, ‘demo_dept’, ‘none_loc’);<br>  INSERT INTO emp(ename, deptno, empno, sal)<br>    VALUES(USER, <strong>90</strong>, <strong>9999</strong>, <strong>3000</strong>);<br>  INSERT INTO emp(ename, deptno, empno, sal)<br>    VALUES(USER, <strong>90</strong>, <strong>9998</strong>, <strong>2000</strong>);<br>  DBMS_OUTPUT.PUT_LINE(‘插入后’);<br>  Disp_dept_summary();</p>
<p>  UPDATE emp SET sal = sal<strong>*1.1</strong> WHERE deptno=<strong>90</strong>;<br>  DBMS_OUTPUT.PUT_LINE(‘修改后’);<br>  Disp_dept_summary();</p>
<p>  DELETE FROM emp WHERE deptno=<strong>90</strong>;<br>  DELETE FROM dept WHERE deptno=<strong>90</strong>;<br>  DBMS_OUTPUT.PUT_LINE(‘删除后’);<br>  Disp_dept_summary();</p>
<p>  DBMS_UTILITY.EXEC_DDL_STATEMENT(‘DROP TRIGGER trig2_update’);<br>  DBMS_UTILITY.EXEC_DDL_STATEMENT(‘DROP TRIGGER trig2_insert’);<br>  DBMS_UTILITY.EXEC_DDL_STATEMENT(‘DROP TRIGGER trig2_delete’);<br>EXCEPTION<br>   WHEN OTHERS THEN<br>      DBMS_OUTPUT.PUT_LINE(SQLCODE||’—‘||SQLERRM);<br>END;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例3：</strong>利用ORACLE提供的条件谓词INSERTING、UPDATING和DELETING创建与例2具有相同功能的触发器。</p>
<p><a href="&quot;复制代码&quot;"></a><br>BEGIN<br>    DBMS_OUTPUT.PUT_LINE(‘插入前’);<br>    Disp_dept_summary();<br>    DBMS_UTILITY.EXEC_DDL_STATEMENT(<br>        ‘CREATE OR REPLACE TRIGGER trig2<br>            AFTER INSERT OR DELETE OR UPDATE OF sal<br>ON emp<br>            REFERENCING OLD AS old_emp NEW AS new_emp<br>            FOR EACH ROW<br>        DECLARE<br>            I NUMBER;<br>        BEGIN<br>            IF UPDATING AND :old_emp.sal != :new_emp.sal THEN<br>            DBMS_OUTPUT.PUT_LINE(‘’正在执行trig2 触发器…’’);<br>                DBMS_OUTPUT.PUT_LINE(‘’sal 旧值：’’|| :old_emp.sal);<br>                DBMS_OUTPUT.PUT_LINE(‘’sal 新值：’’|| :new_emp.sal);<br>                UPDATE dept_summary<br>                    SET sal_sum=sal_sum + :new_emp.sal - :old_emp.sal<br>                WHERE deptno = :new_emp.deptno;<br>            ELSIF INSERTING THEN<br>                DBMS_OUTPUT.PUT_LINE(‘’正在执行trig2触发器…’’);<br>                SELECT COUNT(*) INTO I<br>        FROM dept_summary<br>        WHERE deptno = :new_emp.deptno;<br>                IF I &gt; 0 THEN<br>                    UPDATE dept_summary<br>          SET sal_sum=sal_sum+:new_emp.sal,<br>              Emp_count=emp_count+1<br>          WHERE deptno = :new_emp.deptno;<br>            ELSE<br>          INSERT INTO dept_summary<br>            VALUES (:new_emp.deptno, :new_emp.sal, 1);<br>        END IF;<br>      ELSE<br>        DBMS_OUTPUT.PUT_LINE(‘’正在执行trig2触发器…’’);<br>        SELECT emp_count INTO I<br>        FROM dept_summary WHERE deptno = :old_emp.deptno;<br>      IF I &gt; 1 THEN<br>        UPDATE dept_summary<br>        SET sal_sum=sal_sum - :old_emp.sal,<br>        Emp_count=emp_count - 1<br>        WHERE deptno = :old_emp.deptno;<br>      ELSE<br>          DELETE FROM dept_summary<br>          WHERE deptno = :old_emp.deptno;<br>      END IF;<br>    END IF;<br>    END;’<br>  );</p>
<p>  INSERT INTO dept(deptno, dname, loc)<br>    VALUES(<strong>90</strong>, ‘demo_dept’, ‘none_loc’);<br>  INSERT INTO emp(ename, deptno, empno, sal)<br>    VALUES(USER, <strong>90</strong>, <strong>9999</strong>, <strong>3000</strong>);<br>  INSERT INTO emp(ename, deptno, empno, sal)<br>    VALUES(USER, <strong>90</strong>, <strong>9998</strong>, <strong>2000</strong>);<br>  DBMS_OUTPUT.PUT_LINE(‘插入后’);<br>  Disp_dept_summary();</p>
<p>  UPDATE emp SET sal = sal<strong>*1.1</strong> WHERE deptno=<strong>90</strong>;<br>  DBMS_OUTPUT.PUT_LINE(‘修改后’);<br>  Disp_dept_summary();</p>
<p>  DELETE FROM emp WHERE deptno=<strong>90</strong>;<br>  DELETE FROM dept WHERE deptno=<strong>90</strong>;<br>  DBMS_OUTPUT.PUT_LINE(‘删除后’);<br>  Disp_dept_summary();</p>
<p>  DBMS_UTILITY.EXEC_DDL_STATEMENT(‘DROP TRIGGER trig2’);<br>EXCEPTION<br>   WHEN OTHERS THEN<br>      DBMS_OUTPUT.PUT_LINE(SQLCODE||’—‘||SQLERRM);<br>END;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例4：</strong>创建INSTEAD OF 触发器。首先创建一个视图myview,由于该视图是复合查询所产生的视图，所以不能执行DML语句。根据用户对视图所插入的数据判断需要将数据插入到哪个视图基表中，然后对该基表执行插入操作。</p>
<p><a href="&quot;复制代码&quot;"></a><br>DECLARE<br>    No NUMBER;<br>    Name VARCHAR2(<strong>20</strong>);<br>BEGIN<br>    DBMS_UTILITY.EXEC_DDL_STATEMENT(‘<br>        CREATE OR REPLACE VIEW myview AS<br>            SELECT empno, ename, ‘’E’’ type FROM emp<br>            UNION<br>            SELECT dept.deptno, dname, ‘’D’’ FROM dept<br>    ‘);<br>    – 创建INSTEAD OF 触发器trigger3;<br>    DBMS_UTILITY.EXEC_DDL_STATEMENT(‘<br>        CREATE OR REPLACE TRIGGER trig3<br>            INSTEAD OF INSERT ON myview<br>            REFERENCING NEW n<br>            FOR EACH ROW<br>        DECLARE<br>            Rows INTEGER;<br>        BEGIN<br>            DBMS_OUTPUT.PUT_LINE(‘’正在执行trig3触发器…’’);<br>            IF :n.type = ‘’D’’ THEN<br>                SELECT COUNT(<em>) INTO rows<br>                    FROM dept WHERE deptno = :n.empno;<br>                IF rows = 0 THEN<br>                    DBMS_OUTPUT.PUT_LINE(‘’向dept表中插入数据…’’);<br>                    INSERT INTO dept(deptno, dname, loc)<br>                        VALUES (:n.empno, :n.ename, ‘’none’’);<br>                ELSE<br>                    DBMS_OUTPUT.PUT_LINE(‘’编号为’’|| :n.empno||<br>                     ‘’的部门已存在，插入操作失败！’’);<br>                 END IF;<br>            ELSE<br>                SELECT COUNT(</em>) INTO rows<br>                    FROM emp WHERE empno = :n.empno;<br>                IF rows = 0 THEN<br>                    DBMS_OUTPUT.PUT_LINE(‘’向emp表中插入数据…’’);<br>                    INSERT INTO emp(empno, ename)<br>                        VALUES(:n.empno, :n.ename);<br>                ELSE<br>                    DBMS_OUTPUT.PUT_LINE(‘’编号为’’|| :n.empno||<br>                      ‘’的人员已存在，插入操作失败!’’);<br>                END IF;<br>            END IF;<br>        END;<br>    ‘);</p>
<pre><code>INSERT INTO myview VALUES (70, &apos;demo&apos;, &apos;D&apos;);
INSERT INTO myview VALUES (9999, USER, &apos;E&apos;);
SELECT deptno, dname INTO no, name FROM dept WHERE deptno=70;
DBMS_OUTPUT.PUT_LINE(&apos;员工编号：&apos;||TO_CHAR(no)||&apos;姓名：&apos;||name);
SELECT empno, ename INTO no, name FROM emp WHERE empno=9999;
DBMS_OUTPUT.PUT_LINE(&apos;部门编号：&apos;||TO_CHAR(no)||&apos;姓名：&apos;||name);
</code></pre><p>  DELETE FROM emp WHERE empno=9999;<br>  DELETE FROM dept WHERE deptno=70;<br>    DBMS_UTILITY.EXEC_DDL_STATEMENT(‘DROP TRIGGER trig3’);<br>END;<br><a href="&quot;复制代码&quot;"></a></p>
<p><strong>例5：</strong>利用ORACLE事件属性函数，创建一个系统事件触发器。首先创建一个事件日志表eventlog，由它存储用户在当前数据库中所创建的数据库对象，以及用户的登陆和注销、数据库的启动和关闭等事件，之后创建trig4_ddl、trig4_before和trig4_after触发器，它们调用事件属性函数将各个事件记录到eventlog数据表中。</p>
<hr>
<p><strong><a href="&quot;复制代码&quot;"></a></strong><br>**BEGIN<br>    – 创建用于记录事件日志的数据表<br>    DBMS_UTILITY.EXEC_DDL_STATEMENT(‘<br>        CREATE TABLE eventlog(<br>            Eventname VARCHAR2(20) NOT NULL,<br>            Eventdate date default sysdate,<br>            Inst_num NUMBER NULL,<br>            Db_name VARCHAR2(50) NULL,<br>            Srv_error NUMBER NULL,<br>            Username VARCHAR2(30) NULL,<br>            Obj_type VARCHAR2(20) NULL,<br>            Obj_name VARCHAR2(30) NULL,<br>            Obj_owner VARCHAR2(30) NULL<br>        )<br>    ‘);</p>
<pre><code>-- 创建DDL触发器trig4_ddl
DBMS_UTILITY.EXEC_DDL_STATEMENT(&apos;
    CREATE OR REPLACE TRIGGER trig4_ddl
        AFTER CREATE OR ALTER OR DROP 
</code></pre><p>ON DATABASE<br>        DECLARE<br>            Event VARCHAR2(20);<br>            Typ VARCHAR2(20);<br>            Name VARCHAR2(30);<br>            Owner VARCHAR2(30);<br>        BEGIN<br>            – 读取DDL事件属性<br>            Event := SYSEVENT;<br>            Typ := DICTIONARY_OBJ_TYPE;<br>            Name := DICTIONARY_OBJ_NAME;<br>            Owner := DICTIONARY_OBJ_OWNER;<br>            –将事件属性插入到事件日志表中<br>            INSERT INTO scott.eventlog(eventname, obj_type, obj_name, obj_owner)<br>                VALUES(event, typ, name, owner);<br>        END;<br>    ‘);</p>
<pre><code>-- 创建LOGON、STARTUP和SERVERERROR 事件触发器
DBMS_UTILITY.EXEC_DDL_STATEMENT(&apos;
    CREATE OR REPLACE TRIGGER trig4_after
        AFTER LOGON OR STARTUP OR SERVERERROR 
  ON DATABASE
    DECLARE
        Event VARCHAR2(20);
        Instance NUMBER;
        Err_num NUMBER;
        Dbname VARCHAR2(50);
        User VARCHAR2(30);
    BEGIN
        Event := SYSEVENT;
        IF event = &apos;&apos;LOGON&apos;&apos; THEN
            User := LOGIN_USER;
            INSERT INTO eventlog(eventname, username)
                VALUES(event, user);
        ELSIF event = &apos;&apos;SERVERERROR&apos;&apos; THEN
            Err_num := SERVER_ERROR(1);
            INSERT INTO eventlog(eventname, srv_error)
                VALUES(event, err_num);
        ELSE
            Instance := INSTANCE_NUM;
            Dbname := DATABASE_NAME;
            INSERT INTO eventlog(eventname, inst_num, db_name)
                VALUES(event, instance, dbname);
  END IF;
END;
</code></pre><p>  ‘);</p>
<p>  – 创建LOGOFF和SHUTDOWN 事件触发器<br>  DBMS_UTILITY.EXEC_DDL_STATEMENT(‘<br>    CREATE OR REPLACE TRIGGER trig4_before<br>      BEFORE LOGOFF OR SHUTDOWN<br>      ON DATABASE<br>    DECLARE<br>      Event VARCHAR2(20);<br>      Instance NUMBER;<br>      Dbname VARCHAR2(50);<br>      User VARCHAR2(30);<br>    BEGIN<br>      Event := SYSEVENT;<br>      IF event = ‘’LOGOFF’’ THEN<br>        User := LOGIN_USER;<br>        INSERT INTO eventlog(eventname, username)<br>          VALUES(event, user);<br>      ELSE<br>        Instance := INSTANCE_NUM;<br>        Dbname := DATABASE_NAME;<br>        INSERT INTO eventlog(eventname, inst_num, db_name)<br>          VALUES(event, instance, dbname);<br>      END IF;<br>    END;<br>  ‘);<br>END;</p>
<p>CREATE TABLE mydata(mydate NUMBER);<br>CONNECT SCOTT/TIGER</p>
<p>COL eventname FORMAT A10<br>COL eventdate FORMAT A12<br>COL username FORMAT A10<br>COL obj_type FORMAT A15<br>COL obj_name FORMAT A15<br>COL obj_owner FORMAT A10<br>SELECT eventname, eventdate, obj_type, obj_name, obj_owner, username, Srv_error<br>  FROM eventlog;</p>
<p>DROP TRIGGER trig4_ddl;<br>DROP TRIGGER trig4_before;<br>DROP TRIGGER trig4_after;<br>DROP TABLE eventlog;<br>DROP TABLE mydata;<strong>
</strong><a href="&quot;复制代码&quot;"></a>**</p>
<p><strong>8.6   数据库触发器的应用实例</strong><br>用户可以使用数据库触发器实现各种功能：<br>l         复杂的审计功能；<br>例：将EMP 表的变化情况记录到AUDIT_TABLE和AUDIT_TABLE_VALUES中。</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE TABLE audit_table(<br>    Audit_id     NUMBER,<br>    User_name VARCHAR2(<strong>20</strong>),<br>    Now_time DATE,<br>    Terminal_name VARCHAR2(<strong>10</strong>),<br>    Table_name VARCHAR2(<strong>10</strong>),<br>    Action_name VARCHAR2(<strong>10</strong>),<br>    Emp_id NUMBER(<strong>4</strong>));</p>
<p>CREATE TABLE audit_table_val(<br>    Audit_id NUMBER,<br>    Column_name VARCHAR2(<strong>10</strong>),<br>    Old_val NUMBER(<strong>7</strong>,<strong>2</strong>),<br>    New_val NUMBER(<strong>7</strong>,<strong>2</strong>));</p>
<p>CREATE SEQUENCE audit_seq<br>    START WITH <strong>1000</strong><br>    INCREMENT BY <strong>1</strong><br>    NOMAXVALUE<br>    NOCYCLE NOCACHE;</p>
<p>CREATE OR REPLACE TRIGGER audit_emp<br>    AFTER INSERT OR UPDATE OR DELETE ON emp<br>    FOR EACH ROW<br>DECLARE<br>    Time_now DATE;<br>    Terminal CHAR(<strong>10</strong>);<br>BEGIN<br>    Time_now:=sysdate;<br>    Terminal:=USERENV(‘TERMINAL’);<br>    IF INSERTING THEN<br>        INSERT INTO audit_table<br>    VALUES(audit_seq.NEXTVAL, user, time_now,<br>           terminal, ‘EMP’, ‘INSERT’, :new.empno);<br>    ELSIF DELETING THEN<br>        INSERT INTO audit_table<br>    VALUES(audit_seq.NEXTVAL, user, time_now,<br>           terminal, ‘EMP’, ‘DELETE’, :old.empno);<br>    ELSE<br>        INSERT INTO audit_table<br>    VALUES(audit_seq.NEXTVAL, user, time_now,<br>           terminal, ‘EMP’, ‘UPDATE’, :old.empno);<br>        IF UPDATING(‘SAL’) THEN<br>            INSERT INTO audit_table_val<br>                VALUES(audit_seq.CURRVAL, ‘SAL’, :old.sal, :new.sal);<br>        ELSE UPDATING(‘DEPTNO’)<br>            INSERT INTO audit_table_val<br>                VALUES(audit_seq.CURRVAL, ‘DEPTNO’, :old.deptno, :new.deptno);<br>        END IF;<br>    END IF;<br>END;<br><a href="&quot;复制代码&quot;"></a></p>
<p>l         增强数据的完整性管理；<br>例：修改DEPT表的DEPTNO列时，同时把EMP表中相应的DEPTNO也作相应的修改；</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE SEQUENCE update_sequence<br>    INCREMENT BY <strong>1</strong><br>    START WITH <strong>1000</strong><br>    MAXVALUE <strong>5000</strong> CYCLE;</p>
<p>ALTER TABLE emp<br>    ADD update_id NUMBER;</p>
<p>CREATE OR REPLACE PACKAGE integritypackage AS<br>    Updateseq NUMBER;<br>END integritypackage;</p>
<p>CREATE OR REPLACE PACKAGE BODY integritypackage AS<br>END integritypackage;</p>
<p>CREATE OR REPLACE TRIGGER dept_cascade1<br>    BEFORE UPDATE OF deptno ON dept<br>DECLARE<br>    Dummy NUMBER;<br>BEGIN<br>    SELECT update_sequence.NEXTVAL INTO dummy FROM dual;<br>    Integritypackage.updateseq:=dummy;<br>END;</p>
<p>CREATE OR REPLACE TRIGGER dept_cascade2<br>    AFTER DELETE OR UPDATE OF deptno ON dept<br>    FOR EACH ROW<br>BEGIN<br>    IF UPDATING THEN<br>        UPDATE emp SET deptno=:new.deptno,<br>     update_id=integritypackage.updateseq<br>        WHERE emp.deptno=:old.deptno AND update_id IS NULL;<br>    END IF;<br>    IF DELETING THEN<br>        DELETE FROM emp<br>            WHERE emp.deptno=:old.deptno;<br>    END IF;<br>END;</p>
<p>CREATE OR REPLACE TRIGGER dept_cascade3<br>    AFTER UPDATE OF deptno ON dept<br>BEGIN<br>    UPDATE emp SET update_id=NULL<br>        WHERE update_id=integritypackage.updateseq;<br>END;</p>
<p>SELECT <em> FROM EMP ORDER BY DEPTNO;<br>UPDATE dept SET deptno=<strong>25</strong> WHERE deptno=<em>*20</em></em>;<br><a href="&quot;复制代码&quot;"></a></p>
<p>l         帮助实现安全控制；<br>例：保证对EMP表的修改仅在工作日的工作时间；</p>
<p><a href="&quot;复制代码&quot;"></a><br>CREATE TABLE company_holidays(day DATE);</p>
<p>INSERT INTO company_holidays<br>    VALUES(sysdate);<br>INSERT INTO company_holidays<br>VALUES(TO_DATE(‘21-10月-01’, ‘DD-MON-YY’));</p>
<p>CREATE OR REPLACE TRIGGER emp_permit_change<br>    BEFORE INSERT OR DELETE OR UPDATE ON emp<br>DECLARE<br>    Dummy NUMBER;<br>    Not_on_weekends EXCEPTION;<br>    Not_on_holidays EXCEPTION;<br>    Not_working_hours EXCEPTION;<br>BEGIN<br>    /<em> check for weekends </em>/<br>IF TO_CHAR(SYSDATE, ‘DAY’) IN (‘星期六’, ‘星期日’) THEN<br>    RAISE not_on_weekends;<br>END IF;<br>    /<em> check for company holidays </em>/<br>SELECT COUNT(<em>) INTO dummy FROM company_holidays<br>    WHERE TRUNC(day)=TRUNC(SYSDATE);<br>IF dummy &gt;<strong>0</strong> THEN<br>    RAISE not_on_holidays;<br>END IF;<br>    /</em> check for work hours(8:00 AM to 18:00 PM <em>/<br>IF (TO_CHAR(SYSDATE,’HH24’)&lt;<strong>8</strong> OR TO_CHAR(SYSDATE, ‘HH24’)&gt;<strong>18</strong>) THEN<br>  RAISE not_working_hours;<br>END IF;<br>EXCEPTION<br>  WHEN not_on_weekends THEN<br>    RAISE_APPLICATION_ERROR(-<strong>20324</strong>,<br>‘May not change employee table during the weekends’);<br>  WHEN not_on_holidays THEN<br>    RAISE_APPLICATION_ERROR(-<strong>20325</strong>,<br>‘May not change employee table during a holiday’);<br>  WHEN not_working_hours THEN<br>    RAISE_APPLICATION_ERROR(-<em>*20326</em></em>,<br>‘May not change employee table during no_working hours’);<br>END;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/ORACLE触发器详解/" data-id="cirdhs3cy0007v4nrbjsag0vs" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL ERROR2013完美解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/MySQL ERROR2013完美解决方案/" class="article-date">
  <time datetime="2016-08-02T13:18:52.131Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/MySQL ERROR2013完美解决方案/">MySQL ERROR2013完美解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个错误一般是安装了多个MySQL服务器导致的，解决方案如下：<br>1、进入MySQL安装目录：D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;<br>2、输入mysqld-nt -remove<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;mysqld-nt -remove<br>The service doesn’t exist!</p>
<p>3、输入mysqld-nt -install<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;mysqld-nt -install<br>Service successfully installed.<br>4、输入net start mysql<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;net start mysql<br>MySQL 服务正在启动 ……………….<br>MySQL 服务无法启动。<br>5、输入netstat -ano|findstr 3306<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;netstat -ano|findstr 3306<br>  TCP    0.0.0.0:3306           0.0.0.0:0              LISTENING       5804<br>6、输入taskkill -f -pid 5804（此处的5804即上面的进程ID）<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;taskkill -f -pid 5804<br>成功: 已终止 PID 为 5804 的进程。<br>7、输入net start mysql<br>D:\Program Files (x86)\MySQL\MySQL Server 5.0\bin&gt;net start mysql<br>MySQL 服务正在启动 .<br>MySQL 服务已经启动成功。<br>8、输入mysql -uroot -p进入MySQL</p>
<p>如果设置了环境变量，可在任意目录下执行以上命令</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://HawkAaron.github.io/2016/08/02/MySQL ERROR2013完美解决方案/" data-id="cirdhs3cy0003v4nrj5215sp8" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/02/雅虎刷题狂人曹鹏：10年理论与实践结合的程序员之路/">雅虎刷题狂人曹鹏：10年理论与实践结合的程序员之路</a>
          </li>
        
          <li>
            <a href="/2016/08/02/汇编注释/">汇编注释</a>
          </li>
        
          <li>
            <a href="/2016/08/02/盘点那些快速打开windows程序的快捷键/">盘点那些快速打开windows程序的快捷键</a>
          </li>
        
          <li>
            <a href="/2016/08/02/汇编学习笔记--寄存器（内存访问 1）/">汇编学习笔记--寄存器（内存访问 1）</a>
          </li>
        
          <li>
            <a href="/2016/08/02/win7 64位如何调出debug/">win7 64位如何调出debug</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>