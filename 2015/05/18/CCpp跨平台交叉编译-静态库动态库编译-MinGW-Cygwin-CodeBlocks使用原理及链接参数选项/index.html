<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="DLL,mingw,交叉编译," />





  <link rel="alternate" href="/atom.xml" title="HMK's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="0. 引言UNIX是一个注册商标，是要满足一大堆条件并且支付可观费用才能够被授权使用的一个操作系统。linux是unix的克隆版本，是由其创始人Linus和诸多世界知名的黑客手工打造的一个操作系统。为什么linux和unix之间有很多软件可以很轻松的移植？因为linux也满足POSIX规范，所以在运行机制上跟unix相近。同时，POSIX标准也是Linux、windows下能够进行交叉编译的基础">
<meta property="og:type" content="article">
<meta property="og:title" content="C/C++ 跨平台交叉编译、静态库/动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项">
<meta property="og:url" content="http://HawkAaron.github.io/2015/05/18/CCpp跨平台交叉编译-静态库动态库编译-MinGW-Cygwin-CodeBlocks使用原理及链接参数选项/index.html">
<meta property="og:site_name" content="HMK's blog">
<meta property="og:description" content="0. 引言UNIX是一个注册商标，是要满足一大堆条件并且支付可观费用才能够被授权使用的一个操作系统。linux是unix的克隆版本，是由其创始人Linus和诸多世界知名的黑客手工打造的一个操作系统。为什么linux和unix之间有很多软件可以很轻松的移植？因为linux也满足POSIX规范，所以在运行机制上跟unix相近。同时，POSIX标准也是Linux、windows下能够进行交叉编译的基础">
<meta property="og:image" content="http://images.cnitblog.com/blog/532548/201409/191103358154415.png">
<meta property="og:updated_time" content="2016-08-03T12:27:53.918Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C/C++ 跨平台交叉编译、静态库/动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项">
<meta name="twitter:description" content="0. 引言UNIX是一个注册商标，是要满足一大堆条件并且支付可观费用才能够被授权使用的一个操作系统。linux是unix的克隆版本，是由其创始人Linus和诸多世界知名的黑客手工打造的一个操作系统。为什么linux和unix之间有很多软件可以很轻松的移植？因为linux也满足POSIX规范，所以在运行机制上跟unix相近。同时，POSIX标准也是Linux、windows下能够进行交叉编译的基础">
<meta name="twitter:image" content="http://images.cnitblog.com/blog/532548/201409/191103358154415.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6260393964407358000,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://HawkAaron.github.io/2015/05/18/CCpp跨平台交叉编译-静态库动态库编译-MinGW-Cygwin-CodeBlocks使用原理及链接参数选项/"/>

  <title> C/C++ 跨平台交叉编译、静态库/动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项 | HMK's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HMK's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Stay hungry. Stay foolish.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C/C++ 跨平台交叉编译、静态库/动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2015-05-18T21:00:00+08:00" content="2015-05-18">
              2015-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/DLL/" itemprop="url" rel="index">
                    <span itemprop="name">DLL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/05/18/CCpp跨平台交叉编译-静态库动态库编译-MinGW-Cygwin-CodeBlocks使用原理及链接参数选项/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/18/CCpp跨平台交叉编译-静态库动态库编译-MinGW-Cygwin-CodeBlocks使用原理及链接参数选项/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a><strong>0. 引言</strong></h1><p>UNIX是一个注册商标，是要满足一大堆条件并且支付可观费用才能够被授权使用的一个操作系统。linux是unix的克隆版本，是由其创始人Linus和诸多世界知名的黑客手工打造的一个操作系统。为什么linux和unix之间有很多软件可以很轻松的移植？因为linux也满足POSIX规范，所以在运行机制上跟unix相近。同时，POSIX标准也是Linux、windows下能够进行交叉编译的基础<a id="more"></a></p>
<h2 id="0x1-POSIX-Portable-Operating-System-Interface"><a href="#0x1-POSIX-Portable-Operating-System-Interface" class="headerlink" title="0x1: POSIX(Portable Operating System Interface)"></a><strong><em>0x1: POSIX(Portable Operating System Interface)</em></strong></h2><p>可移植操作系统接口(Portable Operating System Interface POSIX)，是IEEE为要在各种UNIX操作系统上运行的软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。它基本上是(Portable<br> Operating System Interface可移植操作系统接口)的缩写，而X则表明其对Unix API的传承<br>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。微软的Windows NT声称部分实现了POSIX标准，因为有POSIX标准的存在，我们在unix、linux、windows上进行编程的时候，会发现有很多API都是通用的，虽然大多数情况下进行跨系统兼容编程是很困难的<br>当前的POSIX主要分为四个部分</p>
<pre><code>1. Base Definitions
2. System Interfaces
3. Shell and Utilities
4. Rationale
</code></pre><h2 id="0x2-POSIX-1-1标准"><a href="#0x2-POSIX-1-1标准" class="headerlink" title="0x2: POSIX 1.1标准"></a><strong><em>0x2: POSIX 1.1标准</em></strong></h2><p>POSIX(Portable Operating System Interface for Computing Systems)是由IEEE 和ISO/IEC 开发的一簇标准。该标准是基于现有的UNIX实践和经验，描述了操作系统的调用服务接口，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行。</p>
<pre><code>1. 1003.0
    管理POSIX开放式系统环境(OSE)。IEEE在1995年通过了这项标准。ISO的版本是ISO/IEC 14252:1996

2. 1003.1
    被广泛接受、用于源代码级别的可移植性标准。1003.1提供一个操作系统的C语言应用编程接口(API)。IEEE和ISO已经在1990年通过了这个标准，IEEE在1995年重新修订了该标准。

3. 1003.1b
    一个用于实时编程的标准(以前的P1003.4或POSIX.4)。这个标准在1993年被IEEE通过，被合并进ISO/IEC 9945-1

4. 1003.1c
    一个用于线程(在一个程序中当前被执行的代码段)的标准。以前是P1993.4或POSIX.4的一部分，这个标准已经在1995年被IEEE通过，归入ISO/IEC 9945-1:1996

5. 1003.1g
    一个关于协议独立接口的标准，该接口可以使一个应用程序通过网络与另一个应用程序通讯。1996年，IEEE通过了这个标准

6. 1003.2
    一个应用于shell和工具软件的标准，它们分别是操作系统所必须提供的命令处理器和工具程序。1992年IEEE通过了这个标准。ISO也已经通过了这个标准(ISO/IEC 9945-2:1993)

7. 1003.2d
    改进的1003.2标准

8. 1003.5
     一个相当于1003.1的Ada语言的API。在1992年，IEEE通过了这个标准。并在1997年对其进行了修订。ISO也通过了该标准

9. 1003.5b
    一个相当于1003.1b(实时扩展)的Ada语言的API。IEEE和ISO都已经通过了这个标准。ISO的标准是ISO/IEC 14519:1999

10. 1003.5c
    一个相当于1003.1q(协议独立接口)的Ada语言的API。在1998年，IEEE通过了这个标准。ISO也通过了这个标准。

11. 1003.9
    一个相当于1003.1的FORTRAN语言的API。在1992年，IEEE通过了这个标准，并于1997年对其再次确认。ISO也已经通过了这个标准

12. 1003.10
    一个应用于超级计算应用环境框架(Application Environment Profile，AEP)的标准。在1995年，IEEE通过了这个标准

13. 1003.13
    一个关于应用环境框架的标准，主要针对使用POSIX接口的实时应用程序。在1998年，IEEE通过了这个标准 

14. 1003.22
    一个针对POSIX的关于安全性框架的指南

15. 1003.23
    一个针对用户组织的指南，主要是为了指导用户开发和使用支持操作需求的开放式系统环境(OSE)框架

16. 2003
    针对指定和使用是否符合POSIX标准的测试方法，有关其定义、一般需求和指导方针的一个标准。在1997年，IEEE通过了这个标

17. 2003.1
    这个标准规定了针对1003.1的POSIX测试方法的提供商要提供的一些条件。在1992年，IEEE通过了这个标准

18. 2003.2
    一个定义了被用来检查与IEEE 1003.2(shell和工具API)是否符合的测试方法的标准。在1996年，IEEE通过了这个标准
</code></pre><h2 id="0x3-POSIX标准的意义"><a href="#0x3-POSIX标准的意义" class="headerlink" title="0x3: POSIX标准的意义"></a><strong><em>0x3: POSIX标准的意义</em></strong></h2><p>POSIX的意义在于提供了”跨操作系统兼容性编译”的能力，遵循了POSIX标准的C/C++程序源代码，可以直接在Linux/BSD环境下用GCC编译，或者在windows下用Cygwin/MinGW编译(Cygwin、MinGW提供了跨操作系统的兼容编译)。这叫跨操作系统的编译，注意要和”跨平台交叉编译”区分开来<br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="external">http://zh.wikipedia.org/wiki/POSIX</a><br>    <a href="http://i.linuxtoy.org/docs/guide/ch48s05.html" target="_blank" rel="external">http://i.linuxtoy.org/docs/guide/ch48s05.html</a></p>
<h1 id="1-交叉编译"><a href="#1-交叉编译" class="headerlink" title="1. 交叉编译"></a><strong>1. 交叉编译</strong></h1><h2 id="0x1-交叉编译简介"><a href="#0x1-交叉编译简介" class="headerlink" title="0x1: 交叉编译简介"></a><strong><em>0x1: 交叉编译简介</em></strong></h2><p>从编译所在的平台和运行所在的平台这点来看，有两种编译概念<br>    <strong>1. 本地编译</strong><br>    我们常见的软件开发，都是属于”本地编译”。在当前的PC下，x86的CPU下，直接编译出来程序，可以运行的程序(或者库文件)，其可以直接在当前的环境，即x86的CPU下，当前电脑中，运行。<br>    此时的编译，可以叫做”本地编译”，即在当前目标平台下，编译出来的程序，也只是放到当前平台下，就可以运行的<br>    <strong>2. 交叉编译</strong><br>    这是一个和本地编译相对应的概念。而所谓的”交叉编译”，就是在一种平台上编译，编译出来的程序，是放到别的平台上运行<br>    即编译的环境，和运行的环境，不一样，属于交叉的，此所谓cross交叉编译，这个概念，主要和嵌入式开发有关<br>一种最常见的例子就是：<br>    在进行嵌入式开发时，手上有个嵌入式开发板，CPU是arm的，然后在x86的平台下开发，比如Ubuntu的Linux，或者是Win7。然后就需要在x86的平台上，(用交叉编译器)去编译你写好的程序代码，编译生成的(可执行的)程序，是放<br>    到目标开发板，arm的CPU上运行的<br>    此所谓：在x86平台上编译，在ARM平台上运行<br>交叉编译，英文常写作cross compile，也有其他写法：crosscompile, cross compiling等</p>
<h2 id="0x2-为何要有交叉编译"><a href="#0x2-为何要有交叉编译" class="headerlink" title="0x2: 为何要有交叉编译"></a><strong><em>0x2: 为何要有交叉编译</em></strong></h2><p>之所以要有交叉编译，主要原因是：<br>    <strong>1. 嵌入式系统中的资源太少</strong><br>    交叉编译出来的程序，所要运行的目标环境中，各种资源，都相对有限，所以很难进行直接的本地编译，最常见的情况是：<br>    因为编译，开发，都需要相对比较多的CPU，内存，硬盘等资源，而嵌入式开发上的那点资源，只够嵌入式(Linux)系统运行的，没太多剩余的资源，供你本地编译。所以需要在别的平台上进行跨平台编译，然后在其他的平台上运行</p>
<h2 id="0x3-跨平台编译和跨操作系统编译的差别"><a href="#0x3-跨平台编译和跨操作系统编译的差别" class="headerlink" title="0x3: 跨平台编译和跨操作系统编译的差别"></a><strong><em>0x3: 跨平台编译和跨操作系统编译的差别</em></strong></h2><p>这里需要注意的是”平台”的概念，实际上包含两个概念<br>    <strong>1. 体系结构(Architecture)</strong>: 同一个体系结构可以运行不同的操作系统<br>    <strong>2. 操作系统(Operating System)</strong>: 同一个操作系统也可以在不同的体系结构上运行<br>举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称</p>
<p>像crosstool-NG这类交叉编译器和Cygwin这类跨操作系统平台编译器的区别在于</p>
<pre><code>1. crosstool-NG跨平台编译(跨体系结构、操作系统)
2. Cygwin跨平台编译(提供*inux到windows系统的代码级编译兼容性)
</code></pre><p><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://www.crifan.com/files/doc/docbook/cross_compile/release/html/cross_compile.html" target="_blank" rel="external">http://www.crifan.com/files/doc/docbook/cross_compile/release/html/cross_compile.html</a><br>    <a href="http://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</a><br>    <a href="http://baike.baidu.com/view/650389.htm" target="_blank" rel="external">http://baike.baidu.com/view/650389.htm</a></p>
<h1 id="2-Cygwin简介"><a href="#2-Cygwin简介" class="headerlink" title="2. Cygwin简介"></a><strong>2. Cygwin简介</strong></h1><h2 id="0x1-简介"><a href="#0x1-简介" class="headerlink" title="0x1: 简介"></a><strong><em>0x1: 简介</em></strong></h2><p>Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft Windows上，运行类UNIX系统。Cygwin的主要目的是通过”重新编译”(注意：是重新编译)，将POSIX系统(例如Linux、BSD，以及其他Unix系统)上的软件移植到Windows上。Cygwin移植工作在Windows NT上比较好，在Windows 95和Windows 98上，相对差劲一些。目前Cygwin由Red Hat等负责维护</p>
<p>首要需要明白的是，Cygwin不是一个跨平台模拟器，它不能让我们把linux上编译出来的程序在windows上运行(像wine那样)，而是一个跨平台的编译器，也就是提供代码级的跨操作系统兼容性，我们在linux下写的符合POSIX标准的C程序可以在windows下面进行编译，Cygwin提供了一套在windows下可以使用的Linux的API</p>
<p>Cygwin包括了一套库，该库在Win32系统下实现了POSIX系统调用的API。还有一套GNU开发工具集(比如GCC、GDB)，这样可以进行简单的软件开发。还有一些UNIX系统下的常见程序。2001年，新增了X Window System</p>
<h2 id="0x2-Cygwin的特性"><a href="#0x2-Cygwin的特性" class="headerlink" title="0x2: Cygwin的特性"></a><strong><em>0x2: Cygwin的特性</em></strong></h2><pre><code>Cygwin is:
1. a large collection of GNU and Open Source tools which provide functionality similar to a Linux distribution on Windows.
2. a DLL (cygwin1.dll) which provides substantial POSIX API functionality.

Cygwin is not:
1. a way to run native Linux apps on Windows. You must rebuild your application from source if you want it to run on Windows.
2. a way to magically make native Windows apps aware of UNIX® functionality like signals, ptys, etc. Again, you need to build your apps from source if you want to take advantage of Cygwin functionality.
</code></pre><h2 id="0x3-Cygwin原理"><a href="#0x3-Cygwin原理" class="headerlink" title="0x3: Cygwin原理"></a><strong><em>0x3: Cygwin原理</em></strong></h2><p>cygnus当初首先把GCC，GDB，GAS等开发工具进行了改进，使他们能够生成并解释win32的目标文件。然后，他们要把这些工具移植到windows平台上去。一种方案是基于win32 api对这些工具的源代码进行大幅修改，这样做显然需要大量工作。因此，他们采取了一种不同的方法</p>
<ol>
<li>他们写了一个共享库(就是cygwin.dll)，把win32 api中没有的unix风格的调用(如fork、spawn、signals、select、sockets等)封装在里面</li>
<li>也就是说，他们基于win32 api写了一个unix系统库的模拟层(这个模拟层是一个关键，它的底层是win32 api，上层提供unix风格的调用，所以我们才可以在windows下编译unix风格的C程序)</li>
<li>这样，只要把这些工具的源代码和这个共享库连接到一起，就可以使用unix主机上的交叉编译器来生成可以在windows平台上运行的工具集</li>
<li>以这些移植到windows平台上的开发工具为基础，cygnus又逐步把其他的工具(几乎不需要对源代码进行修改，只需要修改他们的配置脚本)软件移植到windows上来。这样，在windows平台上运行bash和开发工具、用户工具，感觉好像在unix上工作</li>
</ol>
<h2 id="0x4-使用Cygwin编程"><a href="#0x4-使用Cygwin编程" class="headerlink" title="0x4: 使用Cygwin编程"></a><strong><em>0x4: 使用Cygwin编程</em></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#iuclude <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译<br>    gcc hello.c -o hello.exe<br>得到hello.exe，这个程序可以在windows上直接点击运行<br><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://zh.wikipedia.org/wiki/Cygwin" target="_blank" rel="external">http://zh.wikipedia.org/wiki/Cygwin</a><br>    <a href="https://www.cygwin.com/" target="_blank" rel="external">https://www.cygwin.com/</a><br>    <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-cygwin/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-cygwin/</a></p>
<h1 id="3-静态库编译及使用"><a href="#3-静态库编译及使用" class="headerlink" title="3. 静态库编译及使用"></a><strong>3. 静态库编译及使用</strong></h1><h2 id="0x1-什么是库"><a href="#0x1-什么是库" class="headerlink" title="0x1: 什么是库"></a><strong><em>0x1: 什么是库</em></strong></h2><p>库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在是很有必要的<br>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种</p>
<pre><code>1. 静态库(.a、.lib)
2. 动态库(.so、.dll)
</code></pre><p>所谓静态、动态是指”链接”的过程存在区别<br><img src="http://images.cnitblog.com/blog/532548/201409/191103358154415.png" alt=""></p>
<h2 id="0x2-动态库和静态库的默认路径PATH搜索顺序"><a href="#0x2-动态库和静态库的默认路径PATH搜索顺序" class="headerlink" title="0x2: 动态库和静态库的默认路径PATH搜索顺序"></a><strong><em>0x2: 动态库和静态库的默认路径PATH搜索顺序</em></strong></h2><p>库文件在连接(静态库和共享库)和运行(仅限于使用共享库的程序)时被使用，其搜索路径是在系统中进行设置的</p>
<pre><code>1. 静态库的搜索路径顺序
    1) /lib
    2) /usr/lib  
    3) /etc/ld.so.conf文件中添加库的搜索路径
    4) /etc/ld.so.conf.d下新建一个.conf文件，这种方法可以很灵活地将不同软件的库搜索路径区分开来
2. 动态库的搜索路径顺序
    1) LD_LIBRARY_PATH 
    2) /lib
    3) /usr/lib  
    4) /etc/ld.so.cache(使用ldconfig生成的库路径缓存)
    5) /etc/ld.so.conf文件中添加库的搜索路径
    6) /etc/ld.so.conf.d下新建一个.conf文件，这种方法可以很灵活地将不同软件的库搜索路径区分开来
</code></pre><h2 id="0x3-静态库"><a href="#0x3-静态库" class="headerlink" title="0x3: 静态库"></a><strong><em>0x3: 静态库</em></strong></h2><p>之所以称之为”静态库”，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。<br>从本质上来说，一个静态库可以简单看成是一组目标文件(.o/.obj文件)的集合，静态库与汇编生成的目标文件(.o/.obj)一起链接为可执行文件<br>静态库和.o文件格式相似。即很多目标文件经过压缩打包后形成的一个文件<br>静态库特点总结：</p>
<pre><code>1. 静态库对函数库的链接是放在编译时期完成的
2. 程序在运行时与函数库再无瓜葛，移植方便，因为代码已经嵌入到程序里面了，可以直接跟着程序走，不存在对外部文件的依赖
3. 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件，会增加原本程序的空间
</code></pre><h2 id="0x4-静态库编程"><a href="#0x4-静态库编程" class="headerlink" title="0x4: 静态库编程"></a><strong><em>0x4: 静态库编程</em></strong></h2><p>我们接下来学习一下如何创建用于C++应用的静态库(一个.lib 文件)。 使用静态库是重用代码的一种绝佳方式。 你不必在要求功能的每个应用中重新实现同一例程，而只需将其写入静态库一次，然后从应用引用它们即可。<br> 从静态库链接的代码成为了应用的一部分，这样你就不必安装另一个文件来使用代码。</p>
<h3 id="1-VS编译、使用静态库"><a href="#1-VS编译、使用静态库" class="headerlink" title="1. VS编译、使用静态库"></a><strong>1. VS编译、使用静态库</strong></h3><pre><code>//创建静态库项目
1. 在菜单栏上，依次选择&quot;文件&quot;、&quot;新建&quot;、&quot;项目&quot;
2. 在&quot;新建项目&quot;对话框的左窗格中，依次展开&quot;已安装&quot;、&quot;模板&quot;、&quot;Visual C++&quot;，然后选择&quot;Win32&quot;
3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;
4. 在&quot;名称&quot;框中为项目指定名称，例如 MathFuncsLib。 在&quot;解决方案名称&quot;框中为解决方案指定名称，例如 StaticLibrary。 选择&quot;确定&quot;按钮
5. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮
6. 在&quot;应用程序设置&quot;页的&quot;应用程序类型&quot;下，选择&quot;静态库&quot;
7. 在&quot;应用程序设置&quot;页的&quot;附加选项&quot;下，清除&quot;预编译头&quot;复选框
8. 选择&quot;完成&quot;按钮创建项目
</code></pre><p>MathFuncsLib.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MathFuncsLib.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATHFUNCSLIB_H  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MATHFUNCSLIB_H  </span></div><div class="line">  </div><div class="line"><span class="keyword">namespace</span> MathFuncs</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> MyMathFuncs</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// Returns a + b</span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// Returns a - b</span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Subtract</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// Returns a * b</span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// Returns a / b</span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Divide</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line">    &#125;;</div><div class="line">&#125;  </div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>MathFuncsLib.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MathFuncsLib.cpp</span></div><div class="line"><span class="comment">// compile with: cl /c /EHsc MathFuncsLib.cpp</span></div><div class="line"><span class="comment">// post-build command: lib MathFuncsLib.obj</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFuncsLib.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> MathFuncs</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Add(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a + b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Subtract(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a - b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Multiply(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a * b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Divide(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a / b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译静态库文件<br>    //编译此静态库</p>
<pre><code>1. 在菜单栏上依次选择&quot;生成&quot;、&quot;生成解决方案&quot;
2. 这将创建一个可供其他程序使用的静态库
</code></pre><p>vs是windows操作系统下的编译平台，通过vs编译得到的.lib静态库只能在windows的程序代码中使用，主要是编译器、汇编器和连接器的不同，因此二者库的二进制是不兼容的。文章之后会学习到如何将linux下编译的静态库通过跨平台编译链接到windows的程序代码中</p>
<p>要在其他程序中使用静态库中的功能，必须引用静态库才能使用其中的例程<br>    //创建引用静态库的 C++ 控制台应用</p>
<pre><code>1. 在菜单栏上，依次选择&quot;文件&quot;、&quot;新建&quot;、&quot;项目&quot;。
2. 在左窗格中的&quot;Visual C++&quot;下，选择&quot;Win32&quot;。
3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;。
4. 在&quot;名称&quot;框中为项目指定名称，例如 MyExecRefsLib。 在&quot;解决方案&quot;旁的下拉列表中选择&quot;添加到解决方案&quot;。 这会将新项目添加到包含此静
5. 态库的解决方案。 选择&quot;确定&quot;按钮。
6. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮。
7. 在&quot;应用程序设置&quot;页的&quot;应用程序类型&quot;下，选择&quot;控制台应用程序&quot;。
8. 在&quot;应用程序设置&quot;页的&quot;附加选项&quot;下，清除&quot;预编译头&quot;复选框。
9. 选择&quot;完成&quot;按钮创建项目。

 //在应用中使用静态库的功能
1. 在创建一个控制台应用程序后，一个空的程序已经为你创建好了。 源文件的名称与你之前选择的名称相同。 在此示例中，源文件名为 MyExecRefsLib.cpp。
2. 必须引用静态库才能使用其中的算术例程。 为此，请在&quot;解决方案资源管理器&quot;中打开 MyExecRefsLib 项目的快捷菜单，然后选择&quot;引用&quot;。 在 MyExecRefsLib&quot;属性页&quot;对话框中，展开&quot;通用属性&quot;节点，选择&quot;框架和引用&quot;，然后选择&quot;添加新引用&quot;按钮。 有关&quot;引用&quot;对话框的更多信息，请参见&quot;&lt;Projectname&gt; 属性页&quot;对话框 -&gt;&quot;通用属性&quot;-&gt;&quot;框架和引用&quot;。
3. &quot;添加引用&quot;对话框列出了可以引用的库。 &quot;项目&quot;选项卡列出了当前解决方案中的所有项目以及它们包含的所有库。 在&quot;项目&quot;选项卡上，选中&quot;MathFuncsLib&quot;复选框，然后选择&quot;确定&quot;按钮。
4. 若要引用 MathFuncsLib.h 头文件，必须修改包含的目录路径。 在 MyExecRefsLib&quot;属性页&quot;对话框中，依次展开&quot;配置属性&quot;节点和&quot;C/C++&quot;节点，然后选择&quot;常规&quot;。 在&quot;附加包含目录&quot;旁，指定 MathFuncsLib 目录的路径或浏览至该目录。
5. 若要浏览至目录路径，请打开属性值下拉列表框，然后选择&quot;编辑&quot;。 在&quot;附加包含目录&quot;对话框中，在文本框中选择一个空行，然后选择行尾的省略号按钮 (…)。 在&quot;选择目录&quot;对话框中，选择 MathFuncsLib 目录，然后选择&quot;选择文件夹&quot;按钮以保存所做选择并关闭对话框。 在&quot;附加包含目录&quot;对话框中，选择&quot;确定&quot;按钮，然后在&quot;属性页&quot;对话框中，选择&quot;确定&quot;按钮以保存对该项目进行的更改。
</code></pre><p>MyExecRefsLib.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyExecRefsLib.cpp</span></div><div class="line"><span class="comment">// compile with: cl /EHsc MyExecRefsLib.cpp /link MathFuncsLib.lib</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFuncsLib.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> a = <span class="number">7.4</span>;</div><div class="line">    <span class="keyword">int</span> b = <span class="number">99</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt;        MathFuncs::MyMathFuncs::Add(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a - b = "</span> &lt;&lt;        MathFuncs::MyMathFuncs::Subtract(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a * b = "</span> &lt;&lt;        MathFuncs::MyMathFuncs::Multiply(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a / b = "</span> &lt;&lt;        MathFuncs::MyMathFuncs::Divide(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://msdn.microsoft.com/zh-cn/library/ms235627.aspx#BKMK_CreateLibProject" target="_blank" rel="external">http://msdn.microsoft.com/zh-cn/library/ms235627.aspx#BKMK_CreateLibProject</a></p>
<p>###<strong>2. GCC编译、使用静态库</strong><br>静态库的后缀是.a(并没有强制规定)，它的产生分两步</p>
<pre><code>1. 由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表
2. ar命令将很多.o转换成.a，成为静态库，从这点也可以看出来，库是很多.o文件的集合
</code></pre><p>在linux下，库文件一般放在/usr/lib和/lib下<br>静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称<br>动态库的名字一般为libxxxx.so.major.minor，xxxx是该lib的名称，major是主版本号，minor是副版本号(如果库的命名不遵循 libXXXXX.a的格式就找不到相应文件)</p>
<pre><code>ldd命令可以查看一个可执行程序依赖的共享库 
ldd /bin/ping
    linux-gate.so.1 =&gt;  (0x006cd000)
    libidn.so.11 =&gt; /lib/libidn.so.11 (0x005d6000)
    libc.so.6 =&gt; /lib/libc.so.6 (0x00927000)
    /lib/ld-linux.so.2 (0x005ac000)
</code></pre><p>首先，我们先完成函数库(静态库的代码)的编码<br>hello.h: 函数库(静态库)的头文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_H</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>hello.c: 函数库的实现代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello%s!\n"</span>, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们可以将当前的代码编译为静态库文件，需要注意的，静态库和可执行在本质上都是可执行代码，但是静态库没有main主程序，所以不能独立运行，需要被引入到别的程序中进行运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//将代码编译为对象文件.o</div><div class="line">gcc -c hello.c</div><div class="line">//将.o链接为静态库文件</div><div class="line">ar rcs libhello.a hello.o</div></pre></td></tr></table></figure></p>
<p>编译好静态库文件之后，我们就可以在其他程序中使用静态库文件中的函数了</p>
<pre><code>1. 只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明(include对应的头文件)
2. 然后在用gcc命令生成目标文件时指明静态库名
3. gcc将会从静态库中将公用函数连接到目标文件中
4. 注意，gcc会在静态库名前加上前缀lib，然后追加扩展名.a得到的静态库文件名来查找静态库文件,因此，我们在写需要连接的库时，只写名字就可以，如libhello.a的库，只写: -lhello
</code></pre><p>main.c: 调用静态库的程序代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    hello(<span class="string">"LittleHann"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译<br>    gcc -o hello main.c -L. -lhello<br>关于gcc的编译指令，请参阅另一篇文章<br>    <a href="http://www.cnblogs.com/LittleHann/p/3855905.html" target="_blank" rel="external">http://www.cnblogs.com/LittleHann/p/3855905.html</a></p>
<p><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://wenku.baidu.com/view/7d8602b265ce050877321301.html" target="_blank" rel="external">http://wenku.baidu.com/view/7d8602b265ce050877321301.html</a></p>
<h1 id="4-动态库编译及使用"><a href="#4-动态库编译及使用" class="headerlink" title="4. 动态库编译及使用"></a><strong>4. 动态库编译及使用</strong></h1><h2 id="0x1-动态库"><a href="#0x1-动态库" class="headerlink" title="0x1: 动态库"></a><strong><em>0x1: 动态库</em></strong></h2><p>动态库文件名命名规范和静态库文件名命名规范类似，也是在动态库名增加前缀lib，但其文件扩展名为.so。例如：我们将创建的动态库名为myhello，则动态库文件名就是libmyhello.so。</p>
<p>接下来我们继续学习如何创建用于 C++ 应用程序的动态链接库 (DLL)。 使用库是重用代码的一种绝佳方式。 您不必在自己创建的每个程序中重新实现同一例程，而只需对这些例程写入一次，然后从需要该功能的应用程序引用它们即可。 通过将代码放入 DLL，您节省在引用它的每个应用程序的空间，而且，您可以更新 DLL，而无需重新编译所有应用程序</p>
<h2 id="0x2-动态库编程"><a href="#0x2-动态库编程" class="headerlink" title="0x2: 动态库编程"></a><strong><em>0x2: 动态库编程</em></strong></h2><h3 id="1-VS编译、使用静态库-1"><a href="#1-VS编译、使用静态库-1" class="headerlink" title="1. VS编译、使用静态库"></a><strong>1. VS编译、使用静态库</strong></h3><pre><code>//创建动态链接库 (DLL) 项目
1. 在菜单栏上，依次选择&quot;文件&quot;、&quot;新建&quot;、&quot;项目&quot;。
2. 在&quot;新建项目&quot;对话框的左窗格中，依次展开&quot;已安装&quot;、&quot;模板&quot;、&quot;Visual C++&quot;，然后选择&quot;Win32&quot;。
3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;。
4. 在&quot;名称&quot;框中为项目指定名称，例如，MathFuncsDll。 在&quot;解决方案名称&quot;框中为解决方案指定一个名称，例如 DynamicLibrary。 选择&quot;确定&quot;按钮。
5. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮。
6. 在&quot;应用程序设置&quot;页上的&quot;应用程序类型&quot;下，选择&quot;DLL&quot;。
7. 选择&quot;完成&quot;按钮创建项目。
</code></pre><p>编写动态库DLL的头文件，MathFuncsDll.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MathFuncsDll.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATHFUNCSDll_H#<span class="meta-keyword">define</span> MATHFUNCSDll_H</span></div><div class="line"></div><div class="line"><span class="comment">/*当定义了 MATHFUNCSDLL_EXPORTS 符号时，MATHFUNCSDLL_API 符号将在此代码中的成员函数声明中设置 __declspec(dllexport) 修饰符，此修饰符使函数能作为 DLL 导出，以供其他应用程序调用</span></div><div class="line">当 MATHFUNCSDLL_EXPORTS 未定义时，MATHFUNCSDLL_API 会在成员函数声明中定义 __declspec(dllimport) 修饰符。 此修饰符能够使编译器优化从 DLL 导入的用于其他应用程序的函数</div><div class="line">默认情况下，生成 MathFuncsDll 项目时会定义 MATHFUNCSDLL_EXPORTS*/</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MATHFUNCSDLL_EXPORTS</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> MATHFUNCSDLL_API __declspec(dllexport) </span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> MATHFUNCSDLL_API __declspec(dllimport) </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> MathFuncs</div><div class="line">&#123;</div><div class="line">    <span class="comment">// This class is exported from the MathFuncsDll.dll</span></div><div class="line">    <span class="keyword">class</span> MyMathFuncs</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>: </div><div class="line">        <span class="comment">// Returns a + b</span></div><div class="line">        <span class="function"><span class="keyword">static</span> MATHFUNCSDLL_API <span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>; </div><div class="line"></div><div class="line">        <span class="comment">// Returns a - b</span></div><div class="line">        <span class="function"><span class="keyword">static</span> MATHFUNCSDLL_API <span class="keyword">double</span> <span class="title">Subtract</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>; </div><div class="line"></div><div class="line">        <span class="comment">// Returns a * b</span></div><div class="line">        <span class="function"><span class="keyword">static</span> MATHFUNCSDLL_API <span class="keyword">double</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>; </div><div class="line"></div><div class="line">        <span class="comment">// Returns a / b</span></div><div class="line">        <span class="comment">// Throws const std::invalid_argument&amp; if b is 0</span></div><div class="line">        <span class="function"><span class="keyword">static</span> MATHFUNCSDLL_API <span class="keyword">double</span> <span class="title">Divide</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>; </div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>编写动态库DLL的函数实现的.cpp文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MathFuncsDll.cpp : Defines the exported functions for the DLL application.</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFuncsDll.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></div><div class="line">	</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="keyword">namespace</span> MathFuncs</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Add(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a + b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Subtract(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a - b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Multiply(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a * b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> MyMathFuncs::Divide(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> invalid_argument(<span class="string">"b cannot be zero!"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> a / b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后可以得到一个.dll文件</p>
<p>编译得到一个dll文件后，我们就在其他的程序代码中去引入这个dll文件，并使用其中的函数功能了</p>
<pre><code>//创建引用 DLL 的应用程序
1. 为了创建一个项目引用你刚刚创建好的DLL，在菜单栏中选择 文件&gt;新建&gt;项目。
2. 在左窗格中的&quot;Visual C++&quot;下，选择&quot;Win32&quot;。
3. 在中间窗格中，选择&quot;Win32 控制台应用程序&quot;。
4. 在&quot;名称&quot;框中为项目指定名称，例如，MyExecRefsDll。 从&quot;解决方案&quot;旁边的下拉列表中选择&quot;添加到解决方案&quot;。 这会将新项目添加到包含 DLL 的同一个解决方案中。 选择&quot;确定&quot;按钮。
5. 在&quot;Win32 应用程序向导&quot;对话框的&quot;概述&quot;页上，选择&quot;下一步&quot;按钮。
6. 在&quot;应用程序设置&quot;页的&quot;应用程序类型&quot;下，选择&quot;控制台应用程序&quot;。
7. 在&quot;应用程序设置&quot;页的&quot;附加选项&quot;下，清除&quot;预编译头&quot;复选框。
8. 选择&quot;完成&quot;按钮创建项目。

//在应用程序中使用类库的功能
1. 在创建一个控制台应用程序后，一个空的程序已经为你创建好了。 源文件的名称与你之前选择的名称相同。 在本示例中，名为&quot;MyExecRefsDll.cpp&quot;。
2. 若要使用您 DLL 中创建的算术例程，必须引用 DLL。 为此，请在 解决方案资源管理器 中选择 MyExecRefsDll 项目，然后在菜单栏上，选择 项目，引用。 在&quot;属性页&quot;对话框中，展开&quot;通用属性&quot;节点，选择&quot;框架和引用&quot;，然后选择&quot;添加新引用&quot;按钮。 有关&quot;引用&quot;对话框的更多信息，请参见&quot;&lt;Projectname&gt; 属性页&quot;对话框 -&gt;&quot;通用属性&quot;-&gt;&quot;框架和引用&quot;。
3. &quot;添加引用&quot;对话框列出了可以引用的库。 &quot;项目&quot;选项卡列出了当前解决方案中的所有项目，以及它们包含的所有库。 在&quot;项目&quot;选项卡上，选中&quot;MathFuncsDll&quot;旁边的复选框，然后选中&quot;确定&quot;按钮。
4. 若要引用 DLL 的头文件，必须修改包含的目录路径。 为此，请在&quot;属性页&quot;对话框中展开&quot;配置属性&quot;节点，然后展开&quot;C/C++&quot;节点，并选择&quot;常规&quot;。 在&quot;附加包含目录&quot;旁边，指定 MathFuncsDll.h 头文件所在位置的路径。 可以使用相对路径（例如 ..\MathFuncsDll\），然后选择&quot;确定&quot;按钮。
5. 现在即可在此应用程序中使用 MyMathFuncs 类。 使用以下代码替换&quot;&quot;的内容：
</code></pre><p>MyExecRefsDll.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyExecRefsDll.cpp</span></div><div class="line"><span class="comment">// compile with: /EHsc /link MathFuncsDll.lib</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFuncsDll.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> a = <span class="number">7.4</span>;</div><div class="line">    <span class="keyword">int</span> b = <span class="number">99</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; MathFuncs::MyMathFuncs::Add(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a - b = "</span> &lt;&lt; MathFuncs::MyMathFuncs::Subtract(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a * b = "</span> &lt;&lt; MathFuncs::MyMathFuncs::Multiply(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a / b = "</span> &lt;&lt; MathFuncs::MyMathFuncs::Divide(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span>    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"a / 0 = "</span> &lt;&lt; MathFuncs::MyMathFuncs::Divide(a, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> invalid_argument &amp;e) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-GCC编译、使用静态库"><a href="#2-GCC编译、使用静态库" class="headerlink" title="2. GCC编译、使用静态库"></a><strong>2. GCC编译、使用静态库</strong></h3><p>foo.h:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> foo_h__</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> foo_h__</span></div><div class="line">	 </div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// foo_h__</span></span></div></pre></td></tr></table></figure></p>
<p>foo.c:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">	 </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Hello LittleHann, I'm a shared library"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译动态库文件.so<br>    gcc -shared -Wall -Werror -fpic -o libfoo.so foo.c</p>
<p>编译好动态库文件之后，我们就可以在其他程序中引入这个动态库文件.so，并使用其中的导出函数</p>
<p>main.c:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></div><div class="line">	 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"This is a shared library test..."</span>);</div><div class="line">    foo();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在main.c中引入了foo.h头文件<br>    gcc -L. -Wall -o test main.c -lfoo</p>
<p>编译成功后，还有一件很重要的事，我们回想一下Linux下静态库、动态库的默认搜索顺序</p>
<pre><code>1) LD_LIBRARY_PATH 
2) /lib
3) /usr/lib  
4) /etc/ld.so.cache(使用ldconfig生成的库路径缓存)
5) /etc/ld.so.conf文件中添加库的搜索路径
6) /etc/ld.so.conf.d下新建一个.conf文件，这种方法可以很灵活地将不同软件的库搜索路径区分开来
</code></pre><p>linux是默认不会去搜索当前目录的，所以我们必须将.so文件复制到默认路径下、或者使用LD_LIBRARY_PATH显示指定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cp libfoo.so /usr/lib</div><div class="line">./<span class="built_in">test</span></div><div class="line">rm <span class="_">-f</span> /usr/lib/libfoo.so</div></pre></td></tr></table></figure></p>
<p><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://msdn.microsoft.com/zh-cn/library/ms235636.aspx" target="_blank" rel="external">http://msdn.microsoft.com/zh-cn/library/ms235636.aspx</a><br>    <a href="http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html" target="_blank" rel="external">http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html</a></p>
<h1 id="5-MinGW简介"><a href="#5-MinGW简介" class="headerlink" title="5. MinGW简介"></a><strong>5. MinGW简介</strong></h1><h2 id="0x1-MinGW是什么"><a href="#0x1-MinGW是什么" class="headerlink" title="0x1: MinGW是什么"></a><strong><em>0x1: MinGW是什么</em></strong></h2><p>MinGW(Minimalist GNU for Windows)，又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件(Win32API)、库和可执行文件</p>
<p>GCC支持的语言大多在MinGW也受支持，其中涵盖</p>
<pre><code>1. C 
2. Objective-C
3. Fortran
4. Ada
5. 对于C语言之外的语言，MinGW使用标准的GNU运行库，如C++使用GNU libstdc++ 
</code></pre><p>但是MinGW使用Windows中的C运行库。因此用MinGW开发的程序不需要额外的第三方DLL支持就可以直接在Windows下运行，而且也不一定必须遵从GPL许可证。这同时造成了MinGW开发的程序只能使用Win32API和跨平台的第三方库，而缺少POSIX支持 ，大多数GNU软件无法在不修改源代码的情况下用MinGW编译</p>
<p>GCC是一个原本用于Unix系统下编程的编译器。不过，现在GCC也有了许多Win32下的移植版本，目前GCC在windows下有三个移植版本</p>
<pre><code>1. MinGW
2. Cygwin
3. Djgpp
</code></pre><p>MinGW是Minimalistic GNU for Windows 的缩写。它是一个建立在GCC和binutils 项目上的编译器系统。和其他GCC的移植版相比，它可以说是最接近Win32的一个了。因为，MinGW几乎支持所有的Win32 API，这也是MinGW的特色之一。它所连接的程序，不需要任何第三方库就可以运行了。在某种程度上看，MinGW更像是VC的替代品</p>
<h2 id="0x3-编程示例"><a href="#0x3-编程示例" class="headerlink" title="0x3: 编程示例"></a><strong><em>0x3: 编程示例</em></strong></h2><p><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://www.mingw.org/" target="_blank" rel="external">http://www.mingw.org/</a><br>    <a href="https://code.google.com/p/msys-cn/wiki/ChapterThree" target="_blank" rel="external">https://code.google.com/p/msys-cn/wiki/ChapterThree</a><br>    <a href="http://wenku.baidu.com/view/c6f71522af45b307e87197a6.html" target="_blank" rel="external">http://wenku.baidu.com/view/c6f71522af45b307e87197a6.html</a></p>
<h1 id="6-CodeBlocks简介"><a href="#6-CodeBlocks简介" class="headerlink" title="6. CodeBlocks简介"></a><strong>6. CodeBlocks简介</strong></h1><p><strong><strong>Relevant Link:</strong></strong><br>    <a href="http://bbs.chinaunix.net/thread-3640636-1-1.html" target="_blank" rel="external">http://bbs.chinaunix.net/thread-3640636-1-1.html</a><br>    <a href="http://zh.wikipedia.org/wiki/Code::Blocks" target="_blank" rel="external">http://zh.wikipedia.org/wiki/Code::Blocks</a><br>    <a href="http://blog.csdn.net/wtfmonking/article/details/17487705" target="_blank" rel="external">http://blog.csdn.net/wtfmonking/article/details/17487705</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DLL/" rel="tag">#DLL</a>
          
            <a href="/tags/mingw/" rel="tag">#mingw</a>
          
            <a href="/tags/交叉编译/" rel="tag">#交叉编译</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/05/16/Java的内存回收机制/" rel="next" title="Java的内存回收机制">
                <i class="fa fa-chevron-left"></i> Java的内存回收机制
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/05/30/CodeBlocks静态链接与动态链接设置/" rel="prev" title="CodeBlocks静态链接与动态链接设置">
                CodeBlocks静态链接与动态链接设置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/05/18/CCpp跨平台交叉编译-静态库动态库编译-MinGW-Cygwin-CodeBlocks使用原理及链接参数选项/"
           data-title="C/C++ 跨平台交叉编译、静态库/动态库编译、MinGW、Cygwin、CodeBlocks使用原理及链接参数选项" data-url="http://HawkAaron.github.io/2015/05/18/CCpp跨平台交叉编译-静态库动态库编译-MinGW-Cygwin-CodeBlocks使用原理及链接参数选项/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="HMK" />
          <p class="site-author-name" itemprop="name">HMK</p>
          <p class="site-description motion-element" itemprop="description">学习经验 & 理论知识</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/HawkAaron/HawkAaron.github.io" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3884310664" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/qq_20480611" title="CSDN blog" target="_blank">CSDN blog</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-引言"><span class="nav-number">1.</span> <span class="nav-text">0. 引言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x1-POSIX-Portable-Operating-System-Interface"><span class="nav-number">1.1.</span> <span class="nav-text">0x1: POSIX(Portable Operating System Interface)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x2-POSIX-1-1标准"><span class="nav-number">1.2.</span> <span class="nav-text">0x2: POSIX 1.1标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x3-POSIX标准的意义"><span class="nav-number">1.3.</span> <span class="nav-text">0x3: POSIX标准的意义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-交叉编译"><span class="nav-number">2.</span> <span class="nav-text">1. 交叉编译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x1-交叉编译简介"><span class="nav-number">2.1.</span> <span class="nav-text">0x1: 交叉编译简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x2-为何要有交叉编译"><span class="nav-number">2.2.</span> <span class="nav-text">0x2: 为何要有交叉编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x3-跨平台编译和跨操作系统编译的差别"><span class="nav-number">2.3.</span> <span class="nav-text">0x3: 跨平台编译和跨操作系统编译的差别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Cygwin简介"><span class="nav-number">3.</span> <span class="nav-text">2. Cygwin简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x1-简介"><span class="nav-number">3.1.</span> <span class="nav-text">0x1: 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x2-Cygwin的特性"><span class="nav-number">3.2.</span> <span class="nav-text">0x2: Cygwin的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x3-Cygwin原理"><span class="nav-number">3.3.</span> <span class="nav-text">0x3: Cygwin原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x4-使用Cygwin编程"><span class="nav-number">3.4.</span> <span class="nav-text">0x4: 使用Cygwin编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-静态库编译及使用"><span class="nav-number">4.</span> <span class="nav-text">3. 静态库编译及使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x1-什么是库"><span class="nav-number">4.1.</span> <span class="nav-text">0x1: 什么是库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x2-动态库和静态库的默认路径PATH搜索顺序"><span class="nav-number">4.2.</span> <span class="nav-text">0x2: 动态库和静态库的默认路径PATH搜索顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x3-静态库"><span class="nav-number">4.3.</span> <span class="nav-text">0x3: 静态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x4-静态库编程"><span class="nav-number">4.4.</span> <span class="nav-text">0x4: 静态库编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-VS编译、使用静态库"><span class="nav-number">4.4.1.</span> <span class="nav-text">1. VS编译、使用静态库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-动态库编译及使用"><span class="nav-number">5.</span> <span class="nav-text">4. 动态库编译及使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x1-动态库"><span class="nav-number">5.1.</span> <span class="nav-text">0x1: 动态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x2-动态库编程"><span class="nav-number">5.2.</span> <span class="nav-text">0x2: 动态库编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-VS编译、使用静态库-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">1. VS编译、使用静态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-GCC编译、使用静态库"><span class="nav-number">5.2.2.</span> <span class="nav-text">2. GCC编译、使用静态库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-MinGW简介"><span class="nav-number">6.</span> <span class="nav-text">5. MinGW简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x1-MinGW是什么"><span class="nav-number">6.1.</span> <span class="nav-text">0x1: MinGW是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x3-编程示例"><span class="nav-number">6.2.</span> <span class="nav-text">0x3: 编程示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-CodeBlocks简介"><span class="nav-number">7.</span> <span class="nav-text">6. CodeBlocks简介</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HMK</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wusthmk"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  

</body>
</html>
